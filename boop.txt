/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"
	"os"

	"github.com/fatih/color"
	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/integration"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

var (
	AnalyzerErrorsMetric = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "analyzer_errors",
		Help: "Number of errors detected by analyzer",
	}, []string{"analyzer_name", "object_name", "namespace"})
)

var coreAnalyzerMap = map[string]common.IAnalyzer{
	"Pod":                            PodAnalyzer{},
	"Deployment":                     DeploymentAnalyzer{},
	"ReplicaSet":                     ReplicaSetAnalyzer{},
	"PersistentVolumeClaim":          PvcAnalyzer{},
	"Service":                        ServiceAnalyzer{},
	"Ingress":                        IngressAnalyzer{},
	"StatefulSet":                    StatefulSetAnalyzer{},
	"CronJob":                        CronJobAnalyzer{},
	"Node":                           NodeAnalyzer{},
	"ValidatingWebhookConfiguration": ValidatingWebhookAnalyzer{},
	"MutatingWebhookConfiguration":   MutatingWebhookAnalyzer{},
}

var additionalAnalyzerMap = map[string]common.IAnalyzer{
	"HorizontalPodAutoScaler": HpaAnalyzer{},
	"PodDisruptionBudget":     PdbAnalyzer{},
	"NetworkPolicy":           NetworkPolicyAnalyzer{},
	"Log":                     LogAnalyzer{},
	"GatewayClass":            GatewayClassAnalyzer{},
	"Gateway":                 GatewayAnalyzer{},
	"HTTPRoute":               HTTPRouteAnalyzer{},
}

func ListFilters() ([]string, []string, []string) {
	coreKeys := make([]string, 0, len(coreAnalyzerMap))
	for k := range coreAnalyzerMap {
		coreKeys = append(coreKeys, k)
	}

	additionalKeys := make([]string, 0, len(additionalAnalyzerMap))
	for k := range additionalAnalyzerMap {
		additionalKeys = append(additionalKeys, k)
	}

	integrationProvider := integration.NewIntegration()
	var integrationAnalyzers []string

	for _, i := range integrationProvider.List() {
		b, _ := integrationProvider.IsActivate(i)
		if b {
			in, err := integrationProvider.Get(i)
			if err != nil {
				fmt.Println(color.RedString(err.Error()))
				os.Exit(1)
			}
			integrationAnalyzers = append(integrationAnalyzers, in.GetAnalyzerName()...)
		}
	}

	return coreKeys, additionalKeys, integrationAnalyzers
}

func GetAnalyzerMap() (map[string]common.IAnalyzer, map[string]common.IAnalyzer) {

	coreAnalyzer := make(map[string]common.IAnalyzer)
	mergedAnalyzerMap := make(map[string]common.IAnalyzer)

	// add core analyzer
	for key, value := range coreAnalyzerMap {
		coreAnalyzer[key] = value
		mergedAnalyzerMap[key] = value
	}

	// add additional analyzer
	for key, value := range additionalAnalyzerMap {
		mergedAnalyzerMap[key] = value
	}

	integrationProvider := integration.NewIntegration()

	for _, i := range integrationProvider.List() {
		b, err := integrationProvider.IsActivate(i)
		if err != nil {
			fmt.Println(color.RedString(err.Error()))
			os.Exit(1)
		}
		if b {
			in, err := integrationProvider.Get(i)
			if err != nil {
				fmt.Println(color.RedString(err.Error()))
				os.Exit(1)
			}
			in.AddAnalyzer(&mergedAnalyzerMap)
		}
	}

	return coreAnalyzer, mergedAnalyzerMap
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"
	"time"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	cron "github.com/robfig/cron/v3"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CronJobAnalyzer struct{}

func (analyzer CronJobAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "CronJob"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "batch",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	cronJobList, err := a.Client.GetClient().BatchV1().CronJobs(a.Namespace).List(a.Context, v1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, cronJob := range cronJobList.Items {
		var failures []common.Failure
		if cronJob.Spec.Suspend != nil && *cronJob.Spec.Suspend {
			doc := apiDoc.GetApiDocV2("spec.suspend")

			failures = append(failures, common.Failure{
				Text:          fmt.Sprintf("CronJob %s is suspended", cronJob.Name),
				KubernetesDoc: doc,
				Sensitive: []common.Sensitive{
					{
						Unmasked: cronJob.Namespace,
						Masked:   util.MaskString(cronJob.Namespace),
					},
					{
						Unmasked: cronJob.Name,
						Masked:   util.MaskString(cronJob.Name),
					},
				},
			})
		} else {
			// check the schedule format
			if _, err := CheckCronScheduleIsValid(cronJob.Spec.Schedule); err != nil {
				doc := apiDoc.GetApiDocV2("spec.schedule")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("CronJob %s has an invalid schedule: %s", cronJob.Name, err.Error()),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: cronJob.Namespace,
							Masked:   util.MaskString(cronJob.Namespace),
						},
						{
							Unmasked: cronJob.Name,
							Masked:   util.MaskString(cronJob.Name),
						},
					},
				})
			}

			// check the starting deadline
			if cronJob.Spec.StartingDeadlineSeconds != nil {
				deadline := time.Duration(*cronJob.Spec.StartingDeadlineSeconds) * time.Second
				if deadline < 0 {
					doc := apiDoc.GetApiDocV2("spec.startingDeadlineSeconds")

					failures = append(failures, common.Failure{
						Text:          fmt.Sprintf("CronJob %s has a negative starting deadline", cronJob.Name),
						KubernetesDoc: doc,
						Sensitive: []common.Sensitive{
							{
								Unmasked: cronJob.Namespace,
								Masked:   util.MaskString(cronJob.Namespace),
							},
							{
								Unmasked: cronJob.Name,
								Masked:   util.MaskString(cronJob.Name),
							},
						},
					})

				}
			}

		}

		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", cronJob.Namespace, cronJob.Name)] = common.PreAnalysis{
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, cronJob.Name, cronJob.Namespace).Set(float64(len(failures)))

		}
	}

	for key, value := range preAnalysis {
		currentAnalysis := common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}

// Check CRON schedule format
func CheckCronScheduleIsValid(schedule string) (bool, error) {
	_, err := cron.ParseStandard(schedule)
	if err != nil {
		return false, err
	}

	return true, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	batchv1 "k8s.io/api/batch/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestCronJobAnalyzer(t *testing.T) {
	suspend := new(bool)
	*suspend = true

	invalidStartingDeadline := new(int64)
	*invalidStartingDeadline = -7

	validStartingDeadline := new(int64)
	*validStartingDeadline = 7

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name: "CJ1",
						// This CronJob won't be list because of namespace filtering.
						Namespace: "test",
					},
				},
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ2",
						Namespace: "default",
					},
					// A suspended CronJob will contribute to failures.
					Spec: batchv1.CronJobSpec{
						Suspend: suspend,
					},
				},
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ3",
						Namespace: "default",
					},
					Spec: batchv1.CronJobSpec{
						// Valid schedule
						Schedule: "*/1 * * * *",

						// Negative starting deadline
						StartingDeadlineSeconds: invalidStartingDeadline,
					},
				},
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ4",
						Namespace: "default",
					},
					Spec: batchv1.CronJobSpec{
						// Invalid schedule
						Schedule: "*** * * * *",
					},
				},
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ5",
						Namespace: "default",
					},
					Spec: batchv1.CronJobSpec{
						// Valid schedule
						Schedule: "*/1 * * * *",

						// Positive starting deadline shouldn't be any problem.
						StartingDeadlineSeconds: validStartingDeadline,
					},
				},
				&batchv1.CronJob{
					// This cronjob shouldn't contribute to any failures.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "successful-cronjob",
						Namespace: "default",
						Annotations: map[string]string{
							"analysisDate": "2022-04-01",
						},
						Labels: map[string]string{
							"app": "example-app",
						},
					},
					Spec: batchv1.CronJobSpec{
						Schedule:          "*/1 * * * *",
						ConcurrencyPolicy: "Allow",
						JobTemplate: batchv1.JobTemplateSpec{
							ObjectMeta: metav1.ObjectMeta{
								Labels: map[string]string{
									"app": "example-app",
								},
							},
							Spec: batchv1.JobSpec{
								Template: v1.PodTemplateSpec{
									Spec: v1.PodSpec{
										Containers: []v1.Container{
											{
												Name:  "example-container",
												Image: "nginx",
											},
										},
										RestartPolicy: v1.RestartPolicyOnFailure,
									},
								},
							},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	cjAnalyzer := CronJobAnalyzer{}
	results, err := cjAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []string{
		"default/CJ2",
		"default/CJ3",
		"default/CJ4",
	}

	require.Equal(t, len(expectations), len(results))

	for i, result := range results {
		require.Equal(t, expectations[i], result.Name)
	}
}

func TestCronJobAnalyzerLabelSelectorFiltering(t *testing.T) {
	suspend := new(bool)
	*suspend = true

	invalidStartingDeadline := new(int64)
	*invalidStartingDeadline = -7

	validStartingDeadline := new(int64)
	*validStartingDeadline = 7

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "cronjob",
						},
					},
				},
				&batchv1.CronJob{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "CJ2",
						Namespace: "default",
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=cronjob",
	}

	cjAnalyzer := CronJobAnalyzer{}
	results, err := cjAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/CJ1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"fmt"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
)

// DeploymentAnalyzer is an analyzer that checks for misconfigured Deployments
type DeploymentAnalyzer struct {
}

// Analyze scans all namespaces for Deployments with misconfigurations
func (d DeploymentAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Deployment"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "apps",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	deployments, err := a.Client.GetClient().AppsV1().Deployments(a.Namespace).List(context.Background(), v1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	for _, deployment := range deployments.Items {
		var failures []common.Failure
		if *deployment.Spec.Replicas != deployment.Status.Replicas {
			doc := apiDoc.GetApiDocV2("spec.replicas")

			failures = append(failures, common.Failure{
				Text:          fmt.Sprintf("Deployment %s/%s has %d replicas but %d are available", deployment.Namespace, deployment.Name, *deployment.Spec.Replicas, deployment.Status.Replicas),
				KubernetesDoc: doc,
				Sensitive: []common.Sensitive{
					{
						Unmasked: deployment.Namespace,
						Masked:   util.MaskString(deployment.Namespace),
					},
					{
						Unmasked: deployment.Name,
						Masked:   util.MaskString(deployment.Name),
					},
				}})
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", deployment.Namespace, deployment.Name)] = common.PreAnalysis{
				FailureDetails: failures,
				Deployment:     deployment,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, deployment.Name, deployment.Namespace).Set(float64(len(failures)))
		}

	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/magiconair/properties/assert"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestDeploymentAnalyzer(t *testing.T) {
	clientset := fake.NewSimpleClientset(&appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "example",
			Namespace: "default",
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: func() *int32 { i := int32(3); return &i }(),
			Template: v1.PodTemplateSpec{
				Spec: v1.PodSpec{
					Containers: []v1.Container{
						{
							Name:  "example-container",
							Image: "nginx",
							Ports: []v1.ContainerPort{
								{
									ContainerPort: 80,
								},
							},
						},
					},
				},
			},
		},
		Status: appsv1.DeploymentStatus{
			Replicas:          2,
			AvailableReplicas: 1,
		},
	})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	deploymentAnalyzer := DeploymentAnalyzer{}
	analysisResults, err := deploymentAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
	assert.Equal(t, analysisResults[0].Kind, "Deployment")
	assert.Equal(t, analysisResults[0].Name, "default/example")
}

func TestDeploymentAnalyzerNamespaceFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: func() *int32 { i := int32(3); return &i }(),
				Template: v1.PodTemplateSpec{
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name:  "example-container",
								Image: "nginx",
								Ports: []v1.ContainerPort{
									{
										ContainerPort: 80,
									},
								},
							},
						},
					},
				},
			},
			Status: appsv1.DeploymentStatus{
				Replicas:          2,
				AvailableReplicas: 1,
			},
		},
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "other-namespace",
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: func() *int32 { i := int32(3); return &i }(),
				Template: v1.PodTemplateSpec{
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name:  "example-container",
								Image: "nginx",
								Ports: []v1.ContainerPort{
									{
										ContainerPort: 80,
									},
								},
							},
						},
					},
				},
			},
			Status: appsv1.DeploymentStatus{
				Replicas:          2,
				AvailableReplicas: 1,
			},
		},
	)

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	deploymentAnalyzer := DeploymentAnalyzer{}
	analysisResults, err := deploymentAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
	assert.Equal(t, analysisResults[0].Kind, "Deployment")
	assert.Equal(t, analysisResults[0].Name, "default/example")
}

func TestDeploymentAnalyzerLabelSelectorFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
				Labels: map[string]string{
					"app": "deployment",
				},
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: func() *int32 { i := int32(3); return &i }(),
				Template: v1.PodTemplateSpec{
					Spec: v1.PodSpec{
						Containers: []v1.Container{},
					},
				},
			},
		},
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example2",
				Namespace: "default",
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: func() *int32 { i := int32(3); return &i }(),
				Template: v1.PodTemplateSpec{
					Spec: v1.PodSpec{
						Containers: []v1.Container{},
					},
				},
			},
		},
	)

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=deployment",
	}

	deploymentAnalyzer := DeploymentAnalyzer{}
	analysisResults, err := deploymentAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ctrl "sigs.k8s.io/controller-runtime/pkg/client"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

type GatewayClassAnalyzer struct{}

// Gateway analyser will analyse all different Kinds and search for missing object dependencies
func (GatewayClassAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "GatewayClass"
	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	gcList := &gtwapi.GatewayClassList{}
	client := a.Client.CtrlClient
	err := gtwapi.AddToScheme(client.Scheme())
	if err != nil {
		return nil, err
	}

	labelSelector := util.LabelStrToSelector(a.LabelSelector)
	if err := client.List(a.Context, gcList, &ctrl.ListOptions{LabelSelector: labelSelector}); err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	// Find all unhealthy gateway Classes

	for _, gc := range gcList.Items {
		var failures []common.Failure

		gcName := gc.GetName()
		// Check only the current condition
		if gc.Status.Conditions[0].Status != metav1.ConditionTrue {
			failures = append(failures, common.Failure{
				Text: fmt.Sprintf(
					"GatewayClass '%s' with a controller name '%s' is not accepted. Message: '%s'.",
					gcName,
					gc.Spec.ControllerName,
					gc.Status.Conditions[0].Message,
				),
				Sensitive: []common.Sensitive{
					{
						Unmasked: gcName,
						Masked:   util.MaskString(gcName),
					},
				},
			})
		}
		if len(failures) > 0 {
			preAnalysis[gcName] = common.PreAnalysis{
				GatewayClass:   gc,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, gcName, "").Set(float64(len(failures)))
		}
	}
	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}
		a.Results = append(a.Results, currentAnalysis)
	}
	return a.Results, nil
}
package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/assert"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/scheme"
	fakeclient "sigs.k8s.io/controller-runtime/pkg/client/fake"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

// Testing with the fake dynamic client if GatewayClasses have an accepted status
func TestGatewayClassAnalyzer(t *testing.T) {
	GatewayClass := &gtwapi.GatewayClass{}
	GatewayClass.Name = "foobar"
	GatewayClass.Spec.ControllerName = "gateway.fooproxy.io/gatewayclass-controller"
	// Initialize Conditions slice before setting properties
	BadCondition := metav1.Condition{
		Type:    "Accepted",
		Status:  "Uknown",
		Message: "Waiting for controller",
		Reason:  "Pending",
	}
	GatewayClass.Status.Conditions = []metav1.Condition{BadCondition}
	// Create a GatewayClassAnalyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(GatewayClass).Build()

	analyzerInstance := GatewayClassAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}

func TestGatewayClassAnalyzerLabelSelectorFiltering(t *testing.T) {
	condition := metav1.Condition{
		Type:    "Accepted",
		Status:  "Ready",
		Message: "Ready",
		Reason:  "Ready",
	}

	// Create two GatewayClasses with different labels
	GatewayClass := &gtwapi.GatewayClass{}
	GatewayClass.Name = "foobar"
	GatewayClass.Spec.ControllerName = "gateway.fooproxy.io/gatewayclass-controller"
	GatewayClass.Labels = map[string]string{"app": "gatewayclass"}
	GatewayClass.Status.Conditions = []metav1.Condition{condition}

	GatewayClass2 := &gtwapi.GatewayClass{}
	GatewayClass2.Name = "foobar2"
	GatewayClass2.Spec.ControllerName = "gateway.fooproxy.io/gatewayclass-controller"
	GatewayClass2.Status.Conditions = []metav1.Condition{condition}

	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(GatewayClass, GatewayClass2).Build()

	analyzerInstance := GatewayClassAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=gatewayclass",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ctrl "sigs.k8s.io/controller-runtime/pkg/client"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

type GatewayAnalyzer struct{}

// Gateway analyser will analyse all different Kinds and search for missing object dependencies
func (GatewayAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Gateway"
	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	gtwList := &gtwapi.GatewayList{}
	gc := &gtwapi.GatewayClass{}
	client := a.Client.CtrlClient
	err := gtwapi.AddToScheme(client.Scheme())
	if err != nil {
		return nil, err
	}

	labelSelector := util.LabelStrToSelector(a.LabelSelector)
	if err := client.List(a.Context, gtwList, &ctrl.ListOptions{LabelSelector: labelSelector}); err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}
	// Find all unhealthy gateway Classes

	for _, gtw := range gtwList.Items {
		var failures []common.Failure

		gtwName := gtw.GetName()
		gtwNamespace := gtw.GetNamespace()
		// Check if gatewayclass exists
		err := client.Get(a.Context, ctrl.ObjectKey{Namespace: gtwNamespace, Name: string(gtw.Spec.GatewayClassName)}, gc, &ctrl.GetOptions{})
		if errors.IsNotFound(err) {
			failures = append(failures, common.Failure{
				Text: fmt.Sprintf(
					"Gateway uses the GatewayClass %s which does not exist.",
					gtw.Spec.GatewayClassName,
				),
				Sensitive: []common.Sensitive{
					{
						Unmasked: string(gtw.Spec.GatewayClassName),
						Masked:   util.MaskString(string(gtw.Spec.GatewayClassName)),
					},
				},
			})
		}

		// Check only the current conditions
		// TODO: maybe check other statuses Listeners, addresses?
		if gtw.Status.Conditions[0].Status != metav1.ConditionTrue {
			failures = append(failures, common.Failure{
				Text: fmt.Sprintf("Gateway '%s/%s' is not accepted. Message: '%s'.",
					gtwNamespace,
					gtwName,
					gtw.Status.Conditions[0].Message,
				),
				Sensitive: []common.Sensitive{
					{
						Unmasked: gtwNamespace,
						Masked:   util.MaskString(gtwNamespace),
					},
					{
						Unmasked: gtwName,
						Masked:   util.MaskString(gtwName),
					},
				},
			})
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", gtwNamespace, gtwName)] = common.PreAnalysis{
				Gateway:        gtw,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, gtwName, gtwNamespace).Set(float64(len(failures)))
		}
	}
	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}
		a.Results = append(a.Results, currentAnalysis)
	}
	return a.Results, nil
}
package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/magiconair/properties/assert"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	fakeclient "sigs.k8s.io/controller-runtime/pkg/client/fake"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

func BuildGatewayClass(name string) gtwapi.GatewayClass {
	GatewayClass := gtwapi.GatewayClass{}
	GatewayClass.Name = name
	// Namespace is not needed outside of this test, GatewayClass is cluster-scoped
	GatewayClass.Namespace = "default"
	GatewayClass.Spec.ControllerName = "gateway.fooproxy.io/gatewayclass-controller"

	return GatewayClass
}

func BuildGateway(className gtwapi.ObjectName, status metav1.ConditionStatus, labels map[string]string) gtwapi.Gateway {
	Gateway := gtwapi.Gateway{}
	Gateway.Name = "foobar"
	Gateway.Namespace = "default"
	if labels != nil {
		Gateway.Labels = labels
	}
	Gateway.Spec.GatewayClassName = className
	Gateway.Spec.Listeners = []gtwapi.Listener{
		{
			Name:     "proxy",
			Port:     80,
			Protocol: gtwapi.HTTPProtocolType,
		},
	}
	Condition := metav1.Condition{
		Type:    "Accepted",
		Status:  status,
		Message: "An expected message",
		Reason:  "Test",
	}
	Gateway.Status.Conditions = []metav1.Condition{Condition}

	return Gateway
}

func TestGatewayAnalyzer(t *testing.T) {
	ClassName := gtwapi.ObjectName("exists")
	AcceptedStatus := metav1.ConditionTrue
	GatewayClass := BuildGatewayClass(string(ClassName))

	Gateway := BuildGateway(ClassName, AcceptedStatus, nil)
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme

	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&Gateway,
		&GatewayClass,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := GatewayAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 0)

}

func TestMissingClassGatewayAnalyzer(t *testing.T) {
	ClassName := gtwapi.ObjectName("non-existed")
	AcceptedStatus := metav1.ConditionTrue
	Gateway := BuildGateway(ClassName, AcceptedStatus, nil)

	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&Gateway,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := GatewayAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}

func TestStatusGatewayAnalyzer(t *testing.T) {
	ClassName := gtwapi.ObjectName("exists")
	AcceptedStatus := metav1.ConditionUnknown
	GatewayClass := BuildGatewayClass(string(ClassName))

	Gateway := BuildGateway(ClassName, AcceptedStatus, nil)

	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&Gateway,
		&GatewayClass,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := GatewayAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	var errorFound bool
	want := "Gateway 'default/foobar' is not accepted. Message: 'An expected message'."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%v> , not found in Gateway's analysis results", want)
	}
}

func TestGatewayAnalyzerLabelSelectorFiltering(t *testing.T) {
	ClassName := gtwapi.ObjectName("non-existed")
	AcceptedStatus := metav1.ConditionTrue

	Gateway := BuildGateway(ClassName, AcceptedStatus, map[string]string{"app": "gateway"})
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&Gateway,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := GatewayAnalyzer{}
	// without label selector should return 1 result
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

	// with label selector should return 1 result
	config = common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=gateway",
	}
	analysisResults, err = analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

	// with wrong label selector should return 0 result
	config = common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=wrong",
	}
	analysisResults, err = analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 0)

}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"strings"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/magiconair/properties/assert"
	appsv1 "k8s.io/api/apps/v1"
	autoscalingv2 "k8s.io/api/autoscaling/v2"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestHPAAnalyzer(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestHPAAnalyzerWithMultipleHPA(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
		},
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example-2",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 2)
}

func TestHPAAnalyzerWithUnsuportedScaleTargetRef(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "unsupported",
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	for _, analysis := range analysisResults {
		for _, err := range analysis.Error {
			if strings.Contains(err.Text, "which is not an option.") {
				errorFound = true
				break
			}
		}
		if errorFound {
			break
		}
	}
	if !errorFound {
		t.Error("expected error 'does not possible option.' not found in analysis results")
	}
}

func TestHPAAnalyzerWithNonExistentScaleTargetRef(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "non-existent",
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	for _, analysis := range analysisResults {
		for _, err := range analysis.Error {
			if strings.Contains(err.Text, "does not exist.") {
				errorFound = true
				break
			}
		}
		if errorFound {
			break
		}
	}
	if !errorFound {
		t.Error("expected error 'does not exist.' not found in analysis results")
	}
}

func TestHPAAnalyzerWithExistingScaleTargetRefAsDeployment(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
		},
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: appsv1.DeploymentSpec{
				Template: corev1.PodTemplateSpec{
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{
							{
								Name:  "example",
								Image: "nginx",
								Resources: corev1.ResourceRequirements{
									Requests: corev1.ResourceList{
										"cpu":    resource.MustParse("100m"),
										"memory": resource.MustParse("128Mi"),
									},
									Limits: corev1.ResourceList{
										"cpu":    resource.MustParse("200m"),
										"memory": resource.MustParse("256Mi"),
									},
								},
							},
						},
					},
				},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	for _, analysis := range analysisResults {
		assert.Equal(t, len(analysis.Error), 0)
	}
}

func TestHPAAnalyzerWithExistingScaleTargetRefAsReplicationController(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "ReplicationController",
					Name: "example",
				},
			},
		},
		&corev1.ReplicationController{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: corev1.ReplicationControllerSpec{
				Template: &corev1.PodTemplateSpec{
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{
							{
								Name:  "example",
								Image: "nginx",
								Resources: corev1.ResourceRequirements{
									Requests: corev1.ResourceList{
										"cpu":    resource.MustParse("100m"),
										"memory": resource.MustParse("128Mi"),
									},
									Limits: corev1.ResourceList{
										"cpu":    resource.MustParse("200m"),
										"memory": resource.MustParse("256Mi"),
									},
								},
							},
						},
					},
				},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	for _, analysis := range analysisResults {
		assert.Equal(t, len(analysis.Error), 0)
	}
}

func TestHPAAnalyzerWithExistingScaleTargetRefAsReplicaSet(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "ReplicaSet",
					Name: "example",
				},
			},
		},
		&appsv1.ReplicaSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: appsv1.ReplicaSetSpec{
				Template: corev1.PodTemplateSpec{
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{
							{
								Name:  "example",
								Image: "nginx",
								Resources: corev1.ResourceRequirements{
									Requests: corev1.ResourceList{
										"cpu":    resource.MustParse("100m"),
										"memory": resource.MustParse("128Mi"),
									},
									Limits: corev1.ResourceList{
										"cpu":    resource.MustParse("200m"),
										"memory": resource.MustParse("256Mi"),
									},
								},
							},
						},
					},
				},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	for _, analysis := range analysisResults {
		assert.Equal(t, len(analysis.Error), 0)
	}
}

func TestHPAAnalyzerWithExistingScaleTargetRefAsStatefulSet(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "StatefulSet",
					Name: "example",
				},
			},
		},
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: appsv1.StatefulSetSpec{
				Template: corev1.PodTemplateSpec{
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{
							{
								Name:  "example",
								Image: "nginx",
								Resources: corev1.ResourceRequirements{
									Requests: corev1.ResourceList{
										"cpu":    resource.MustParse("100m"),
										"memory": resource.MustParse("128Mi"),
									},
									Limits: corev1.ResourceList{
										"cpu":    resource.MustParse("200m"),
										"memory": resource.MustParse("256Mi"),
									},
								},
							},
						},
					},
				},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	for _, analysis := range analysisResults {
		assert.Equal(t, len(analysis.Error), 0)
	}
}

func TestHPAAnalyzerWithExistingScaleTargetRefWithoutSpecifyingResources(t *testing.T) {

	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
		},
		&appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: appsv1.DeploymentSpec{
				Template: corev1.PodTemplateSpec{
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{
							{
								Name:  "example",
								Image: "nginx",
							},
						},
					},
				},
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	for _, analysis := range analysisResults {
		for _, err := range analysis.Error {
			if strings.Contains(err.Text, "does not have resource configured.") {
				errorFound = true
				break
			}
			if errorFound {
				break
			}
		}
		if !errorFound {
			t.Error("expected error 'does not have resource configured.' not found in analysis results")
		}
	}
}

func TestHPAAnalyzerNamespaceFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
		},
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "other-namespace",
				Annotations: map[string]string{},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestHPAAnalyzerLabelSelectorFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
				Labels: map[string]string{
					"app": "hpa",
				},
			},
		},
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example2",
				Namespace: "default",
			},
		},
	)
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=hpa",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestHPAAnalyzerStatusFieldAbleToScale(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
			Status: autoscalingv2.HorizontalPodAutoscalerStatus{
				Conditions: []autoscalingv2.HorizontalPodAutoscalerCondition{
					{
						Type:    "AbleToScale",
						Status:  "False",
						Message: "test reason",
					},
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}

func TestHPAAnalyzerStatusFieldScalingActive(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
			Status: autoscalingv2.HorizontalPodAutoscalerStatus{
				Conditions: []autoscalingv2.HorizontalPodAutoscalerCondition{
					{
						Type:    autoscalingv2.ScalingActive,
						Status:  "False",
						Message: "test reason",
					},
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}

func TestHPAAnalyzerStatusFieldScalingLimited(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
			Status: autoscalingv2.HorizontalPodAutoscalerStatus{
				Conditions: []autoscalingv2.HorizontalPodAutoscalerCondition{
					{
						Type:    autoscalingv2.ScalingLimited,
						Status:  "False",
						Message: "test reason",
					},
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}

func TestHPAAnalyzerStatusField(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:        "example",
				Namespace:   "default",
				Annotations: map[string]string{},
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					Kind: "Deployment",
					Name: "example",
				},
			},
			Status: autoscalingv2.HorizontalPodAutoscalerStatus{
				Conditions: []autoscalingv2.HorizontalPodAutoscalerCondition{
					{
						Type:    autoscalingv2.AbleToScale,
						Status:  "True",
						Message: "recommended size matches current size",
					},
					{
						Type:    autoscalingv2.ScalingActive,
						Status:  "True",
						Message: "the HPA was able to successfully calculate a replica count",
					},
					{
						Type:    autoscalingv2.ScalingLimited,
						Status:  "True",
						Message: "the desired replica count is less than the minimum replica count",
					},
				},
			},
		})
	hpaAnalyzer := HpaAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := hpaAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)

}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type HpaAnalyzer struct{}

func (HpaAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "HorizontalPodAutoscaler"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "autoscaling",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	list, err := a.Client.GetClient().AutoscalingV2().HorizontalPodAutoscalers(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, hpa := range list.Items {
		var failures []common.Failure

		//check the error from status field
		conditions := hpa.Status.Conditions
		for _, condition := range conditions {
			if condition.Status != "True" {
				failures = append(failures, common.Failure{
					Text:      condition.Message,
					Sensitive: []common.Sensitive{},
				})
			}
		}

		// check ScaleTargetRef exist
		scaleTargetRef := hpa.Spec.ScaleTargetRef
		var podInfo PodInfo

		switch scaleTargetRef.Kind {
		case "Deployment":
			deployment, err := a.Client.GetClient().AppsV1().Deployments(hpa.Namespace).Get(a.Context, scaleTargetRef.Name, metav1.GetOptions{})
			if err == nil {
				podInfo = DeploymentInfo{deployment}
			}
		case "ReplicationController":
			rc, err := a.Client.GetClient().CoreV1().ReplicationControllers(hpa.Namespace).Get(a.Context, scaleTargetRef.Name, metav1.GetOptions{})
			if err == nil {
				podInfo = ReplicationControllerInfo{rc}
			}
		case "ReplicaSet":
			rs, err := a.Client.GetClient().AppsV1().ReplicaSets(hpa.Namespace).Get(a.Context, scaleTargetRef.Name, metav1.GetOptions{})
			if err == nil {
				podInfo = ReplicaSetInfo{rs}
			}
		case "StatefulSet":
			ss, err := a.Client.GetClient().AppsV1().StatefulSets(hpa.Namespace).Get(a.Context, scaleTargetRef.Name, metav1.GetOptions{})
			if err == nil {
				podInfo = StatefulSetInfo{ss}
			}
		default:
			failures = append(failures, common.Failure{
				Text:      fmt.Sprintf("HorizontalPodAutoscaler uses %s as ScaleTargetRef which is not an option.", scaleTargetRef.Kind),
				Sensitive: []common.Sensitive{},
			})
		}

		if podInfo == nil {
			doc := apiDoc.GetApiDocV2("spec.scaleTargetRef")

			failures = append(failures, common.Failure{
				Text:          fmt.Sprintf("HorizontalPodAutoscaler uses %s/%s as ScaleTargetRef which does not exist.", scaleTargetRef.Kind, scaleTargetRef.Name),
				KubernetesDoc: doc,
				Sensitive: []common.Sensitive{
					{
						Unmasked: scaleTargetRef.Name,
						Masked:   util.MaskString(scaleTargetRef.Name),
					},
				},
			})
		} else {
			containers := len(podInfo.GetPodSpec().Containers)
			for _, container := range podInfo.GetPodSpec().Containers {
				if container.Resources.Requests == nil || container.Resources.Limits == nil {
					containers--
				}
			}

			if containers <= 0 {
				doc := apiDoc.GetApiDocV2("spec.scaleTargetRef.kind")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("%s %s/%s does not have resource configured.", scaleTargetRef.Kind, a.Namespace, scaleTargetRef.Name),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: scaleTargetRef.Name,
							Masked:   util.MaskString(scaleTargetRef.Name),
						},
					},
				})
			}

		}

		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", hpa.Namespace, hpa.Name)] = common.PreAnalysis{
				HorizontalPodAutoscalers: hpa,
				FailureDetails:           failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, hpa.Name, hpa.Namespace).Set(float64(len(failures)))
		}

	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.HorizontalPodAutoscalers.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}

type PodInfo interface {
	GetPodSpec() corev1.PodSpec
}

type DeploymentInfo struct {
	*appsv1.Deployment
}

func (d DeploymentInfo) GetPodSpec() corev1.PodSpec {
	return d.Spec.Template.Spec
}

// define a structure for ReplicationController
type ReplicationControllerInfo struct {
	*corev1.ReplicationController
}

func (rc ReplicationControllerInfo) GetPodSpec() corev1.PodSpec {
	return rc.Spec.Template.Spec
}

// define a structure for ReplicaSet
type ReplicaSetInfo struct {
	*appsv1.ReplicaSet
}

func (rs ReplicaSetInfo) GetPodSpec() corev1.PodSpec {
	return rs.Spec.Template.Spec
}

// define a structure for StatefulSet
type StatefulSetInfo struct {
	*appsv1.StatefulSet
}

// implement PodInfo for StatefulSetInfo
func (ss StatefulSetInfo) GetPodSpec() corev1.PodSpec {
	return ss.Spec.Template.Spec
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	ctrl "sigs.k8s.io/controller-runtime/pkg/client"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

type HTTPRouteAnalyzer struct{}

// Gateway analyser will analyse all different Kinds and search for missing object dependencies
func (HTTPRouteAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "HTTPRoute"
	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	routeList := &gtwapi.HTTPRouteList{}
	gtw := &gtwapi.Gateway{}
	service := &corev1.Service{}
	client := a.Client.CtrlClient
	err := gtwapi.AddToScheme(client.Scheme())
	if err != nil {
		return nil, err
	}

	labelSelector := util.LabelStrToSelector(a.LabelSelector)
	if err := client.List(a.Context, routeList, &ctrl.ListOptions{LabelSelector: labelSelector}); err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	// Find all unhealthy gateway Classes
	for _, route := range routeList.Items {
		var failures []common.Failure

		// Check if Gateways exists in the same or designated namespace
		// TODO: when meshes and ClusterIp options are adopted we can add more checks
		// e.g Service Port matching
		for _, gtwref := range route.Spec.ParentRefs {
			namespace := route.Namespace
			if gtwref.Namespace != nil {
				namespace = string(*gtwref.Namespace)
			}
			err := client.Get(a.Context, ctrl.ObjectKey{Namespace: namespace, Name: string(gtwref.Name)}, gtw, &ctrl.GetOptions{})
			if errors.IsNotFound(err) {
				failures = append(failures, common.Failure{
					Text: fmt.Sprintf(
						"HTTPRoute uses the Gateway '%s/%s' which does not exist in the same namespace.",
						namespace,
						gtwref.Name,
					),
					Sensitive: []common.Sensitive{
						{
							Unmasked: gtw.Namespace,
							Masked:   util.MaskString(gtw.Namespace),
						},
						{
							Unmasked: gtw.Name,
							Masked:   util.MaskString(gtw.Name),
						},
					},
				})
			} else {
				// Check if the aforementioned Gateway allows the HTTPRoutes from the route's namespace
				for _, listener := range gtw.Spec.Listeners {
					if listener.AllowedRoutes.Namespaces != nil {
						switch allow := listener.AllowedRoutes.Namespaces.From; {
						case *allow == gtwapi.NamespacesFromSame:
							// check if Gateway is in the same namespace
							if route.Namespace != gtw.Namespace {
								failures = append(failures, common.Failure{
									Text: fmt.Sprintf("HTTPRoute '%s/%s' is deployed in a different namespace from Gateway '%s/%s' which only allows HTTPRoutes from its namespace.",
										route.Namespace,
										route.Name,
										gtw.Namespace,
										gtw.Name,
									),
									Sensitive: []common.Sensitive{
										{
											Unmasked: route.Namespace,
											Masked:   util.MaskString(route.Namespace),
										},
										{
											Unmasked: route.Name,
											Masked:   util.MaskString(route.Name),
										},
										{
											Unmasked: gtw.Namespace,
											Masked:   util.MaskString(gtw.Namespace),
										},
										{
											Unmasked: gtw.Name,
											Masked:   util.MaskString(gtw.Name),
										},
									},
								})
							}
						case *allow == gtwapi.NamespacesFromSelector:
							// check if our route include the same selector Label
							if !util.LabelsIncludeAny(listener.AllowedRoutes.Namespaces.Selector.MatchLabels, route.Labels) {
								failures = append(failures, common.Failure{
									Text: fmt.Sprintf(
										"HTTPRoute '%s/%s' can't be attached on Gateway '%s/%s', selector labels do not match HTTProute's labels.",
										route.Namespace,
										route.Name,
										gtw.Namespace,
										gtw.Name,
									),
									Sensitive: []common.Sensitive{
										{
											Unmasked: route.Namespace,
											Masked:   util.MaskString(route.Namespace),
										},
										{
											Unmasked: route.Name,
											Masked:   util.MaskString(route.Name),
										},
										{
											Unmasked: gtw.Namespace,
											Masked:   util.MaskString(gtw.Namespace),
										},
										{
											Unmasked: gtw.Name,
											Masked:   util.MaskString(gtw.Name),
										},
									},
								})

							}

						}
					}
				}
			}

		}
		// Check if the Backends are valid services and ports are matching with services Ports
		for _, rule := range route.Spec.Rules {
			for _, backend := range rule.BackendRefs {
				err := client.Get(a.Context, ctrl.ObjectKey{Namespace: route.Namespace, Name: string(backend.Name)}, service, &ctrl.GetOptions{})
				if errors.IsNotFound(err) {
					failures = append(failures, common.Failure{
						Text: fmt.Sprintf(
							"HTTPRoute uses the Service '%s/%s' which does not exist.",
							route.Namespace,
							backend.Name,
						),
						Sensitive: []common.Sensitive{
							{
								Unmasked: service.Namespace,
								Masked:   util.MaskString(service.Namespace),
							},
							{
								Unmasked: service.Name,
								Masked:   util.MaskString(service.Name),
							},
						},
					})
				} else {
					portMatch := false
					for _, svcPort := range service.Spec.Ports {
						if int32(*backend.Port) == svcPort.Port {
							portMatch = true
						}
					}
					if !portMatch {
						failures = append(failures, common.Failure{
							Text: fmt.Sprintf(
								"HTTPRoute's backend service '%s' is using port '%d' but the corresponding K8s service '%s/%s' isn't configured with the same port.",
								backend.Name,
								int32(*backend.Port),
								service.Namespace,
								service.Name,
							),
							Sensitive: []common.Sensitive{
								{
									Unmasked: string(backend.Name),
									Masked:   util.MaskString(string(backend.Name)),
								},
								{
									Unmasked: service.Name,
									Masked:   util.MaskString(service.Name),
								},
								{
									Unmasked: service.Namespace,
									Masked:   service.Namespace,
								},
							},
						})
					}
				}
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", route.Namespace, route.Name)] = common.PreAnalysis{
				HTTPRoute:      route,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, route.Name, route.Namespace).Set(float64(len(failures)))
		}
	}
	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}
		a.Results = append(a.Results, currentAnalysis)
	}
	return a.Results, nil

}
package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	corev1 "k8s.io/api/core/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes/scheme"
	fakeclient "sigs.k8s.io/controller-runtime/pkg/client/fake"
	gtwapi "sigs.k8s.io/gateway-api/apis/v1"
)

func BuildRouteGateway(namespace, name, fromNamespaceref string) gtwapi.Gateway {
	routeNamespace := &gtwapi.RouteNamespaces{}
	switch fromNamespaceref {
	case "Same":
		fromSame := gtwapi.NamespacesFromSame
		routeNamespace.From = &fromSame
	case "Selector":
		fromSelector := gtwapi.NamespacesFromSelector
		routeNamespace.From = &fromSelector
		routeNamespace.Selector = &metav1.LabelSelector{}
		routeNamespace.Selector.MatchLabels = map[string]string{"foo": "bar"}

	default:
		fromAll := gtwapi.NamespacesFromAll
		routeNamespace.From = &fromAll
	}
	Gateway := gtwapi.Gateway{}
	Gateway.Name = name
	Gateway.Namespace = namespace
	Gateway.Spec.GatewayClassName = "fooclassName"
	Gateway.Spec.Listeners = []gtwapi.Listener{
		{
			Name:     "proxy",
			Port:     80,
			Protocol: gtwapi.HTTPProtocolType,
			AllowedRoutes: &gtwapi.AllowedRoutes{
				Namespaces: routeNamespace,
			},
		},
	}
	Condition := metav1.Condition{
		Type:    "Accepted",
		Status:  "True",
		Message: "An expected message",
		Reason:  "Test",
	}
	Gateway.Status.Conditions = []metav1.Condition{Condition}

	return Gateway
}

func BuildHTTPRoute(backendName, gtwName gtwapi.ObjectName, gtwNamespace gtwapi.Namespace, svcPort *gtwapi.PortNumber, namespace string) gtwapi.HTTPRoute {
	HTTPRoute := gtwapi.HTTPRoute{}
	HTTPRoute.Name = "foohttproute"
	HTTPRoute.Namespace = namespace
	HTTPRoute.Spec.ParentRefs = []gtwapi.ParentReference{
		{
			Name:      gtwName,
			Namespace: &gtwNamespace,
		},
	}
	HTTPRoute.Spec.Rules = []gtwapi.HTTPRouteRule{
		{
			BackendRefs: []gtwapi.HTTPBackendRef{
				{
					BackendRef: gtwapi.BackendRef{
						BackendObjectReference: gtwapi.BackendObjectReference{
							Name: backendName,
							Port: svcPort,
						},
					},
				},
			},
		},
	}
	return HTTPRoute
}

/*
	Testing different cases

1. Gateway doesn't exist or at least doesn't exist in the same namespace
2. Gateway exists in different namespace, is configured in httproute's spec
and Gateway's configuration is allowing only from its same namespace
3. Gateway exists in the same namespace but has selectors different from route's labels
4. BackendRef is pointing to a non existent Service
5. BackendRef's port and Service Port are different
*/
func TestGWMissiningHTTRouteAnalyzer(t *testing.T) {
	backendName := gtwapi.ObjectName("foobackend")
	gtwName := gtwapi.ObjectName("non-existent")
	gtwNamespace := gtwapi.Namespace("non-existent")
	svcPort := gtwapi.PortNumber(1027)
	httpRouteNamespace := "default"

	HTTPRoute := BuildHTTPRoute(backendName, gtwName, gtwNamespace, &svcPort, httpRouteNamespace)
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&HTTPRoute,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := HTTPRouteAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "HTTPRoute uses the Gateway 'non-existent/non-existent' which does not exist in the same namespace."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%s> , not found in HTTPRoute's analysis results", want)
	}

}

func TestGWConfigSameHTTRouteAnalyzer(t *testing.T) {
	backendName := gtwapi.ObjectName("foobackend")
	gtwName := gtwapi.ObjectName("gatewayname")
	gtwNamespace := gtwapi.Namespace("differentnamespace")
	svcPort := gtwapi.PortNumber(1027)
	httpRouteNamespace := "default"

	HTTPRoute := BuildHTTPRoute(backendName, gtwName, gtwNamespace, &svcPort, httpRouteNamespace)

	Gateway := BuildRouteGateway("differentnamespace", "gatewayname", "Same")
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&HTTPRoute,
		&Gateway,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := HTTPRouteAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "HTTPRoute 'default/foohttproute' is deployed in a different namespace from Gateway 'differentnamespace/gatewayname' which only allows HTTPRoutes from its namespace."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%s> , not found in HTTPRoute's analysis results", want)
	}
}
func TestGWConfigSelectorHTTRouteAnalyzer(t *testing.T) {
	backendName := gtwapi.ObjectName("foobackend")
	gtwName := gtwapi.ObjectName("gatewayname")
	gtwNamespace := gtwapi.Namespace("default")
	svcPort := gtwapi.PortNumber(1027)
	httpRouteNamespace := "default"

	HTTPRoute := BuildHTTPRoute(backendName, gtwName, gtwNamespace, &svcPort, httpRouteNamespace)

	Gateway := BuildRouteGateway("default", "gatewayname", "Selector")
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&HTTPRoute,
		&Gateway,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := HTTPRouteAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "HTTPRoute 'default/foohttproute' can't be attached on Gateway 'default/gatewayname', selector labels do not match HTTProute's labels."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%s> , not found in HTTPRoute's analysis results", want)
	}
}

func TestSvcMissingHTTRouteAnalyzer(t *testing.T) {
	backendName := gtwapi.ObjectName("foobackend")
	gtwName := gtwapi.ObjectName("gatewayname")
	gtwNamespace := gtwapi.Namespace("default")
	svcPort := gtwapi.PortNumber(1027)
	httpRouteNamespace := "default"

	HTTPRoute := BuildHTTPRoute(backendName, gtwName, gtwNamespace, &svcPort, httpRouteNamespace)

	Gateway := BuildRouteGateway("default", "gatewayname", "Same")
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&HTTPRoute,
		&Gateway,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := HTTPRouteAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "HTTPRoute uses the Service 'default/foobackend' which does not exist."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%s> , not found in HTTPRoute's analysis results", want)
	}
}
func TestSvcDifferentPortHTTRouteAnalyzer(t *testing.T) {
	//Add a Service Object
	Service := corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "foobackend",
			Namespace: "default",
		},
		Spec: corev1.ServiceSpec{
			Selector: map[string]string{
				"app": "example-app",
			},
			Ports: []corev1.ServicePort{
				{
					Name:       "http",
					Protocol:   "TCP",
					Port:       80,
					TargetPort: intstr.FromInt(8080),
				},
			},
			Type: corev1.ServiceTypeClusterIP,
		},
	}
	backendName := gtwapi.ObjectName("foobackend")
	gtwName := gtwapi.ObjectName("gatewayname")
	gtwNamespace := gtwapi.Namespace("default")
	// different port
	svcPort := gtwapi.PortNumber(1027)
	httpRouteNamespace := "default"

	HTTPRoute := BuildHTTPRoute(backendName, gtwName, gtwNamespace, &svcPort, httpRouteNamespace)

	Gateway := BuildRouteGateway("default", "gatewayname", "Same")
	// Create a Gateway Analyzer instance with the fake client
	scheme := scheme.Scheme
	err := gtwapi.Install(scheme)
	if err != nil {
		t.Error(err)
	}
	err = apiextensionsv1.AddToScheme(scheme)
	if err != nil {
		t.Error(err)
	}
	objects := []runtime.Object{
		&HTTPRoute,
		&Gateway,
		&Service,
	}

	fakeClient := fakeclient.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(objects...).Build()

	analyzerInstance := HTTPRouteAnalyzer{}
	config := common.Analyzer{
		Client: &kubernetes.Client{
			CtrlClient: fakeClient,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := analyzerInstance.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "HTTPRoute's backend service 'foobackend' is using port '1027' but the corresponding K8s service 'default/foobackend' isn't configured with the same port."
	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}

	if !errorFound {
		t.Errorf("Expected message, <%s> , not found in HTTPRoute's analysis results", want)
	}
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type IngressAnalyzer struct{}

func (IngressAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Ingress"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "networking",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	list, err := a.Client.GetClient().NetworkingV1().Ingresses(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, ing := range list.Items {
		var failures []common.Failure

		// get ingressClassName
		ingressClassName := ing.Spec.IngressClassName
		if ingressClassName == nil {
			ingClassValue := ing.Annotations["kubernetes.io/ingress.class"]
			if ingClassValue == "" {
				doc := apiDoc.GetApiDocV2("spec.ingressClassName")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Ingress %s/%s does not specify an Ingress class.", ing.Namespace, ing.Name),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: ing.Namespace,
							Masked:   util.MaskString(ing.Namespace),
						},
						{
							Unmasked: ing.Name,
							Masked:   util.MaskString(ing.Name),
						},
					},
				})
			} else {
				ingressClassName = &ingClassValue
			}
		}

		// check if ingressclass exist
		if ingressClassName != nil {
			_, err := a.Client.GetClient().NetworkingV1().IngressClasses().Get(a.Context, *ingressClassName, metav1.GetOptions{})
			if err != nil {
				doc := apiDoc.GetApiDocV2("spec.ingressClassName")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Ingress uses the ingress class %s which does not exist.", *ingressClassName),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: *ingressClassName,
							Masked:   util.MaskString(*ingressClassName),
						},
					},
				})
			}
		}

		// loop over rules
		for _, rule := range ing.Spec.Rules {
			// loop over HTTP paths
			if rule.HTTP != nil {
				for _, path := range rule.HTTP.Paths {
					_, err := a.Client.GetClient().CoreV1().Services(ing.Namespace).Get(a.Context, path.Backend.Service.Name, metav1.GetOptions{})
					if err != nil {
						doc := apiDoc.GetApiDocV2("spec.rules.http.paths.backend.service")

						failures = append(failures, common.Failure{
							Text:          fmt.Sprintf("Ingress uses the service %s/%s which does not exist.", ing.Namespace, path.Backend.Service.Name),
							KubernetesDoc: doc,
							Sensitive: []common.Sensitive{
								{
									Unmasked: ing.Namespace,
									Masked:   util.MaskString(ing.Namespace),
								},
								{
									Unmasked: path.Backend.Service.Name,
									Masked:   util.MaskString(path.Backend.Service.Name),
								},
							},
						})
					}
				}
			}
		}

		for _, tls := range ing.Spec.TLS {
			_, err := a.Client.GetClient().CoreV1().Secrets(ing.Namespace).Get(a.Context, tls.SecretName, metav1.GetOptions{})
			if err != nil {
				doc := apiDoc.GetApiDocV2("spec.tls.secretName")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Ingress uses the secret %s/%s as a TLS certificate which does not exist.", ing.Namespace, tls.SecretName),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: ing.Namespace,
							Masked:   util.MaskString(ing.Namespace),
						},
						{
							Unmasked: tls.SecretName,
							Masked:   util.MaskString(tls.SecretName),
						},
					},
				})
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", ing.Namespace, ing.Name)] = common.PreAnalysis{
				Ingress:        ing,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, ing.Name, ing.Namespace).Set(float64(len(failures)))

		}

	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.Ingress.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestIngressAnalyzer(t *testing.T) {
	validIgClassName := new(string)
	*validIgClassName = "valid-ingress-class"

	var igRule networkingv1.IngressRule

	httpRule := networkingv1.HTTPIngressRuleValue{
		Paths: []networkingv1.HTTPIngressPath{
			{
				Path: "/",
				Backend: networkingv1.IngressBackend{
					Service: &networkingv1.IngressServiceBackend{
						// This service exists.
						Name: "Service1",
					},
				},
			},
			{
				Path: "/test1",
				Backend: networkingv1.IngressBackend{
					Service: &networkingv1.IngressServiceBackend{
						// This service is in the test namespace
						// Hence, it won't be discovered.
						Name: "Service2",
					},
				},
			},
			{
				Path: "/test2",
				Backend: networkingv1.IngressBackend{
					Service: &networkingv1.IngressServiceBackend{
						// This service doesn't exist.
						Name: "Service3",
					},
				},
			},
		},
	}
	igRule.IngressRuleValue.HTTP = &httpRule

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&networkingv1.Ingress{
					// Doesn't specify an ingress class.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress1",
						Namespace: "default",
					},
				},
				&networkingv1.Ingress{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress2",
						Namespace: "default",
						// Specify an invalid ingress class name using annotations.
						Annotations: map[string]string{
							"kubernetes.io/ingress.class": "invalid-class",
						},
					},
				},
				&networkingv1.Ingress{
					// Namespace filtering.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress3",
						Namespace: "test",
					},
				},
				&networkingv1.IngressClass{
					ObjectMeta: metav1.ObjectMeta{
						Name: *validIgClassName,
					},
				},
				&networkingv1.Ingress{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress4",
						Namespace: "default",
						// Specify valid ingress class name using annotations.
						Annotations: map[string]string{
							"kubernetes.io/ingress.class": *validIgClassName,
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Service1",
						Namespace: "default",
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						// Namespace filtering.
						Name:      "Service2",
						Namespace: "test",
					},
				},
				&v1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Secret1",
						Namespace: "default",
					},
				},
				&v1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Secret2",
						Namespace: "test",
					},
				},
				&networkingv1.Ingress{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress5",
						Namespace: "default",
					},

					// Specify valid ingress class name in spec.
					Spec: networkingv1.IngressSpec{
						IngressClassName: validIgClassName,
						Rules: []networkingv1.IngressRule{
							igRule,
						},
						TLS: []networkingv1.IngressTLS{
							{
								// This won't contribute to any failures.
								SecretName: "Secret1",
							},
							{
								// This secret won't be discovered because of namespace filtering.
								SecretName: "Secret2",
							},
							{
								// This secret doesn't exist.
								SecretName: "Secret3",
							},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	igAnalyzer := IngressAnalyzer{}
	results, err := igAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []struct {
		name          string
		failuresCount int
	}{
		{
			name:          "default/Ingress1",
			failuresCount: 1,
		},
		{
			name:          "default/Ingress2",
			failuresCount: 1,
		},
		{
			name:          "default/Ingress5",
			failuresCount: 4,
		},
	}

	require.Equal(t, len(expectations), len(results))

	for i, result := range results {
		require.Equal(t, expectations[i].name, result.Name)
		require.Equal(t, expectations[i].failuresCount, len(result.Error))
	}
}

func TestIngressAnalyzerLabelSelectorFiltering(t *testing.T) {
	validIgClassName := new(string)
	*validIgClassName = "valid-ingress-class"

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&networkingv1.Ingress{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "ingress",
						},
					},
				},
				&networkingv1.Ingress{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Ingress2",
						Namespace: "default",
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=ingress",
	}

	igAnalyzer := IngressAnalyzer{}
	results, err := igAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/Ingress1", results[0].Name)

}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var (
	errorPattern = regexp.MustCompile(`(error|exception|fail)`)
	tailLines    = int64(100)
)

type LogAnalyzer struct {
}

func (LogAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Log"

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// search all namespaces for pods that are not running
	list, err := a.Client.GetClient().CoreV1().Pods(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}
	// Iterate through each pod

	for _, pod := range list.Items {
		podName := pod.Name
		for _, c := range pod.Spec.Containers {
			var failures []common.Failure
			podLogOptions := v1.PodLogOptions{
				TailLines: &tailLines,
				Container: c.Name,
			}
			podLogs, err := a.Client.Client.CoreV1().Pods(pod.Namespace).GetLogs(podName, &podLogOptions).DoRaw(a.Context)
			if err != nil {
				failures = append(failures, common.Failure{
					Text: fmt.Sprintf("Error %s from Pod %s", err.Error(), pod.Name),
					Sensitive: []common.Sensitive{
						{
							Unmasked: pod.Name,
							Masked:   util.MaskString(pod.Name),
						},
					},
				})
			} else {
				rawlogs := string(podLogs)
				if errorPattern.MatchString(strings.ToLower(rawlogs)) {
					failures = append(failures, common.Failure{
						Text: printErrorLines(rawlogs, errorPattern),
						Sensitive: []common.Sensitive{
							{
								Unmasked: pod.Name,
								Masked:   util.MaskString(pod.Name),
							},
						},
					})
				}
			}
			if len(failures) > 0 {
				preAnalysis[fmt.Sprintf("%s/%s/%s", pod.Namespace, pod.Name, c.Name)] = common.PreAnalysis{
					FailureDetails: failures,
					Pod:            pod,
				}
				AnalyzerErrorsMetric.WithLabelValues(kind, pod.Name, pod.Namespace).Set(float64(len(failures)))
			}
		}
	}
	for key, value := range preAnalysis {
		currentAnalysis := common.Result{
			Kind:  "Pod",
			Name:  key,
			Error: value.FailureDetails,
		}
		parent, found := util.GetParent(a.Client, value.Pod.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
func printErrorLines(logs string, errorPattern *regexp.Regexp) string {
	// Split the logs into lines
	logLines := strings.Split(logs, "\n")

	// Check each line for errors and print the lines containing errors
	for _, line := range logLines {
		if errorPattern.MatchString(strings.ToLower(line)) {
			return line
		}
	}
	return ""
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"regexp"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestLogAnalyzer(t *testing.T) {
	oldPattern := errorPattern
	errorPattern = regexp.MustCompile(`(fake logs)`)
	t.Cleanup(func() {
		errorPattern = oldPattern
	})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod1",
						Namespace: "default",
						Labels: map[string]string{
							"Name":      "Pod1",
							"Namespace": "default",
						},
					},
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name: "test-container1",
							},
							{
								Name: "test-container2",
							},
						},
					},
				},
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod2",
						Namespace: "default",
						Labels: map[string]string{
							"Name":      "Pod1",
							"Namespace": "default",
						},
					},
				},
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod3",
						Namespace: "test-namespace",
						Labels: map[string]string{
							"Name":      "Pod1",
							"Namespace": "test-namespace",
						},
					},
				},
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod4",
						Namespace: "default",
						Labels: map[string]string{
							"Name":      "Pod4",
							"Namespace": "default",
						},
					},
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name: "test-container3",
							},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	logAnalyzer := LogAnalyzer{}
	results, err := logAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []string{"default/Pod1/test-container1", "default/Pod1/test-container2", "default/Pod4/test-container3"}

	for i, expectation := range expectations {
		require.Equal(t, expectation, results[i].Name)

		for _, failure := range results[i].Error {
			require.Equal(t, "fake logs", failure.Text)
		}
	}
}

func TestLogAnalyzerLabelSelectorFiltering(t *testing.T) {
	oldPattern := errorPattern
	errorPattern = regexp.MustCompile(`(fake logs)`)
	t.Cleanup(func() {
		errorPattern = oldPattern
	})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "log",
						},
					},
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name: "test-container1",
							},
						},
					},
				},
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod2",
						Namespace: "default",
					},
					Spec: v1.PodSpec{
						Containers: []v1.Container{
							{
								Name: "test-container2",
							},
						},
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=log",
	}

	logAnalyzer := LogAnalyzer{}
	results, err := logAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/Pod1/test-container1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type MutatingWebhookAnalyzer struct{}

func (MutatingWebhookAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "MutatingWebhookConfiguration"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "apps",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	mutatingWebhooks, err := a.Client.GetClient().AdmissionregistrationV1().MutatingWebhookConfigurations().List(context.Background(), v1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, webhookConfig := range mutatingWebhooks.Items {
		for _, webhook := range webhookConfig.Webhooks {
			var failures []common.Failure

			if webhook.ClientConfig.Service == nil {
				continue
			}
			svc := webhook.ClientConfig.Service
			// Get the service
			service, err := a.Client.GetClient().CoreV1().Services(svc.Namespace).Get(context.Background(), svc.Name, v1.GetOptions{})
			if err != nil {
				// If the service is not found, we can't check the pods
				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Service %s not found as mapped to by Mutating Webhook %s", svc.Name, webhook.Name),
					KubernetesDoc: apiDoc.GetApiDocV2("spec.webhook.clientConfig.service"),
					Sensitive: []common.Sensitive{
						{
							Unmasked: webhookConfig.Namespace,
							Masked:   util.MaskString(webhookConfig.Namespace),
						},
						{
							Unmasked: svc.Name,
							Masked:   util.MaskString(svc.Name),
						},
					},
				})
				preAnalysis[fmt.Sprintf("%s/%s", webhookConfig.Namespace, webhook.Name)] = common.PreAnalysis{
					MutatingWebhook: webhookConfig,
					FailureDetails:  failures,
				}
				AnalyzerErrorsMetric.WithLabelValues(kind, webhook.Name, webhookConfig.Namespace).Set(float64(len(failures)))
				continue
			}

			// When Service selectors are empty we defer to service analyser
			if len(service.Spec.Selector) == 0 {
				continue
			}
			// Get pods within service
			pods, err := a.Client.GetClient().CoreV1().Pods(svc.Namespace).List(context.Background(), v1.ListOptions{
				LabelSelector: util.MapToString(service.Spec.Selector),
			})
			if err != nil {
				return nil, err
			}

			if len(pods.Items) == 0 {
				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("No active pods found within service %s as mapped to by Mutating Webhook %s", svc.Name, webhook.Name),
					KubernetesDoc: apiDoc.GetApiDocV2("spec.webhook.clientConfig.service"),
					Sensitive: []common.Sensitive{
						{
							Unmasked: webhookConfig.Namespace,
							Masked:   util.MaskString(webhookConfig.Namespace),
						},
					},
				})

			}
			for _, pod := range pods.Items {
				if pod.Status.Phase != "Running" {
					doc := apiDoc.GetApiDocV2("spec.webhook")
					failures = append(failures, common.Failure{
						Text: fmt.Sprintf(
							"Mutating Webhook (%s) is pointing to an inactive receiver pod (%s)",
							webhook.Name,
							pod.Name,
						),
						KubernetesDoc: doc,
						Sensitive: []common.Sensitive{
							{
								Unmasked: webhookConfig.Namespace,
								Masked:   util.MaskString(webhookConfig.Namespace),
							},
							{
								Unmasked: webhook.Name,
								Masked:   util.MaskString(webhook.Name),
							},
							{
								Unmasked: pod.Name,
								Masked:   util.MaskString(pod.Name),
							},
						},
					})
				}
			}
			if len(failures) > 0 {
				preAnalysis[fmt.Sprintf("%s/%s", webhookConfig.Namespace, webhook.Name)] = common.PreAnalysis{
					MutatingWebhook: webhookConfig,
					FailureDetails:  failures,
				}
				AnalyzerErrorsMetric.WithLabelValues(kind, webhook.Name, webhookConfig.Namespace).Set(float64(len(failures)))
			}
		}
	}
	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.MutatingWebhook.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2024 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestMutatingWebhookAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod1",
						Namespace: "default",
						Labels: map[string]string{
							"pod": "Pod1",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service1",
						Namespace: "default",
					},
					Spec: v1.ServiceSpec{
						Selector: map[string]string{
							"pod": "Pod1",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service2",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						// No such pod exists in the test namespace
						Selector: map[string]string{
							"pod": "Pod2",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service3",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						// len(service.Spec.Selector) == 0
						Selector: map[string]string{},
					},
				},
				&admissionregistrationv1.MutatingWebhookConfiguration{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-mutating-webhook-config",
						Namespace: "test",
					},
					Webhooks: []admissionregistrationv1.MutatingWebhook{
						{
							// Failure: Pointing to an inactive receiver pod
							Name: "webhook1",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service1",
									Namespace: "default",
								},
							},
						},
						{
							// Failure: No active pods found in the test namespace
							Name: "webhook2",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service2",
									Namespace: "test",
								},
							},
						},
						{
							Name: "webhook3",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service3",
									Namespace: "test",
								},
							},
						},
						{
							// Failure: Service doesn't exist.
							Name: "webhook4",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service4-doesn't-exist",
									Namespace: "test",
								},
							},
						},
						{
							// Service is nil.
							Name:         "webhook5",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	mwAnalyzer := MutatingWebhookAnalyzer{}
	results, err := mwAnalyzer.Analyze(config)
	require.NoError(t, err)

	// The results should contain: webhook1, webhook2, and webhook4
	resultsLen := 3
	require.Equal(t, resultsLen, len(results))
}

func TestMutatingWebhookAnalyzerLabelSelectorFiltering(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "mutating-webhook",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service1",
						Namespace: "default",
					},
					Spec: v1.ServiceSpec{
						Selector: map[string]string{
							"app": "mutating-webhook",
						},
					},
				},
				&admissionregistrationv1.MutatingWebhookConfiguration{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-mutating-webhook-config",
						Namespace: "default",
						Labels: map[string]string{
							"app": "mutating-webhook",
						},
					},
					Webhooks: []admissionregistrationv1.MutatingWebhook{
						{
							Name: "webhook1",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service1",
									Namespace: "default",
								},
							},
						},
					},
				},
				&admissionregistrationv1.MutatingWebhookConfiguration{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-mutating-webhook-config2",
						Namespace: "default",
					},
					Webhooks: []admissionregistrationv1.MutatingWebhook{
						{
							Name: "webhook2",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service1",
									Namespace: "default",
								},
							},
						},
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=mutating-webhook",
	}

	mwAnalyzer := MutatingWebhookAnalyzer{}
	results, err := mwAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/webhook1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type NetworkPolicyAnalyzer struct{}

func (NetworkPolicyAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "NetworkPolicy"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "networking",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// get all network policies in the namespace
	policies, err := a.Client.GetClient().NetworkingV1().
		NetworkPolicies(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, policy := range policies.Items {
		var failures []common.Failure

		// Check if policy allows traffic to all pods in the namespace
		if len(policy.Spec.PodSelector.MatchLabels) == 0 {
			doc := apiDoc.GetApiDocV2("spec.podSelector.matchLabels")

			failures = append(failures, common.Failure{
				Text:          fmt.Sprintf("Network policy allows traffic to all pods: %s", policy.Name),
				KubernetesDoc: doc,
				Sensitive: []common.Sensitive{
					{
						Unmasked: policy.Name,
						Masked:   util.MaskString(policy.Name),
					},
				},
			})
		} else {
			// Check if policy is not applied to any pods
			podList, err := util.GetPodListByLabels(a.Client.GetClient(), a.Namespace, policy.Spec.PodSelector.MatchLabels)
			if err != nil {
				return nil, err
			}
			if len(podList.Items) == 0 {
				failures = append(failures, common.Failure{
					Text: fmt.Sprintf("Network policy is not applied to any pods: %s", policy.Name),
					Sensitive: []common.Sensitive{
						{
							Unmasked: policy.Name,
							Masked:   util.MaskString(policy.Name),
						},
					},
				})
			}
		}

		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", policy.Namespace, policy.Name)] = common.PreAnalysis{
				FailureDetails: failures,
				NetworkPolicy:  policy,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, policy.Name, policy.Namespace).Set(float64(len(failures)))

		}
	}

	for key, value := range preAnalysis {
		currentAnalysis := common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/magiconair/properties/assert"
	v1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestNetpolNoPods(t *testing.T) {
	clientset := fake.NewSimpleClientset(&networkingv1.NetworkPolicy{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "example",
			Namespace: "default",
		},
		Spec: networkingv1.NetworkPolicySpec{
			PodSelector: metav1.LabelSelector{
				MatchLabels: map[string]string{
					"app": "example",
				},
			},
			Ingress: []networkingv1.NetworkPolicyIngressRule{
				{
					From: []networkingv1.NetworkPolicyPeer{
						{
							PodSelector: &metav1.LabelSelector{
								MatchLabels: map[string]string{
									"app": "database",
								},
							},
						},
					},
				},
			},
		},
	})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	analyzer := NetworkPolicyAnalyzer{}
	results, err := analyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	assert.Equal(t, len(results), 1)
	assert.Equal(t, results[0].Kind, "NetworkPolicy")

}

func TestNetpolWithPod(t *testing.T) {
	clientset := fake.NewSimpleClientset(&networkingv1.NetworkPolicy{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "example",
			Namespace: "default",
		},
		Spec: networkingv1.NetworkPolicySpec{
			PodSelector: metav1.LabelSelector{
				MatchLabels: map[string]string{
					"app": "example",
				},
			},
			Ingress: []networkingv1.NetworkPolicyIngressRule{
				{
					From: []networkingv1.NetworkPolicyPeer{
						{
							PodSelector: &metav1.LabelSelector{
								MatchLabels: map[string]string{
									"app": "database",
								},
							},
						},
					},
				},
			},
		},
	}, &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "example",
			Namespace: "default",
			Labels: map[string]string{
				"app": "example",
			},
		},
		Spec: v1.PodSpec{
			Containers: []v1.Container{
				{
					Name:  "example",
					Image: "example",
				},
			},
		},
	})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	analyzer := NetworkPolicyAnalyzer{}
	results, err := analyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	assert.Equal(t, len(results), 0)
}

func TestNetpolNoPodsNamespaceFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "policy-without-podselector-match-labels",
				Namespace: "default",
			},
			Spec: networkingv1.NetworkPolicySpec{
				PodSelector: metav1.LabelSelector{
					// len(MatchLabels) == 0 should trigger a failure.
					// Allowing traffic to all pods.
					MatchLabels: map[string]string{},
				},
			},
		},
		&networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: networkingv1.NetworkPolicySpec{
				PodSelector: metav1.LabelSelector{
					MatchLabels: map[string]string{
						"app": "example",
					},
				},
				Ingress: []networkingv1.NetworkPolicyIngressRule{
					{
						From: []networkingv1.NetworkPolicyPeer{
							{
								PodSelector: &metav1.LabelSelector{
									MatchLabels: map[string]string{
										"app": "database",
									},
								},
							},
						},
					},
				},
			},
		},
		&networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "other-namespace",
			},
			Spec: networkingv1.NetworkPolicySpec{
				PodSelector: metav1.LabelSelector{
					MatchLabels: map[string]string{
						"app": "example",
					},
				},
				Ingress: []networkingv1.NetworkPolicyIngressRule{
					{
						From: []networkingv1.NetworkPolicyPeer{
							{
								PodSelector: &metav1.LabelSelector{
									MatchLabels: map[string]string{
										"app": "database",
									},
								},
							},
						},
					},
				},
			},
		})

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	analyzer := NetworkPolicyAnalyzer{}
	results, err := analyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	assert.Equal(t, len(results), 2)
	assert.Equal(t, results[0].Kind, "NetworkPolicy")

}

func TestNetpolLabelSelectorFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example1",
				Namespace: "default",
				Labels: map[string]string{
					"app": "netpol",
				},
			},
			Spec: networkingv1.NetworkPolicySpec{
				PodSelector: metav1.LabelSelector{
					MatchLabels: map[string]string{
						"app": "netpol",
					},
				},
			},
		},
		&networkingv1.NetworkPolicy{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example2",
				Namespace: "default",
			},
		},
	)

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=netpol",
	}

	analyzer := NetworkPolicyAnalyzer{}
	results, err := analyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(results), 1)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	v1 "k8s.io/api/core/v1"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type NodeAnalyzer struct{}

func (NodeAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Node"

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	list, err := a.Client.GetClient().CoreV1().Nodes().List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, node := range list.Items {
		var failures []common.Failure
		for _, nodeCondition := range node.Status.Conditions {
			// https://kubernetes.io/docs/concepts/architecture/nodes/#condition
			switch nodeCondition.Type {
			case v1.NodeReady:
				if nodeCondition.Status == v1.ConditionTrue {
					break
				}
				failures = addNodeConditionFailure(failures, node.Name, nodeCondition)
			// k3s `EtcdIsVoter`` should not be reported as an error
			case v1.NodeConditionType("EtcdIsVoter"):
				break
			default:
				if nodeCondition.Status != v1.ConditionFalse {
					failures = addNodeConditionFailure(failures, node.Name, nodeCondition)
				}
			}
		}

		if len(failures) > 0 {
			preAnalysis[node.Name] = common.PreAnalysis{
				Node:           node,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, node.Name, "").Set(float64(len(failures)))

		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.Node.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, err
}

func addNodeConditionFailure(failures []common.Failure, nodeName string, nodeCondition v1.NodeCondition) []common.Failure {
	failures = append(failures, common.Failure{
		Text: fmt.Sprintf("%s has condition of type %s, reason %s: %s", nodeName, nodeCondition.Type, nodeCondition.Reason, nodeCondition.Message),
		Sensitive: []common.Sensitive{
			{
				Unmasked: nodeName,
				Masked:   util.MaskString(nodeName),
			},
		},
	})
	return failures
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestNodeAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Node{
					// A node without Status Conditions shouldn't contribute to failures.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Node1",
						Namespace: "test",
					},
				},
				&v1.Node{
					// Nodes are not filtered using namespace.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Node2",
						Namespace: "default",
					},
					Status: v1.NodeStatus{
						Conditions: []v1.NodeCondition{
							{
								// Won't contribute to failures.
								Type:   v1.NodeReady,
								Status: v1.ConditionTrue,
							},
							{
								// Will contribute to failures.
								Type:   v1.NodeReady,
								Status: v1.ConditionFalse,
							},
							{
								// Will contribute to failures.
								Type:   v1.NodeReady,
								Status: v1.ConditionUnknown,
							},
							// Non-false statuses for the default cases contribute to failures.
							{
								Type:   v1.NodeMemoryPressure,
								Status: v1.ConditionTrue,
							},
							{
								Type:   v1.NodeDiskPressure,
								Status: v1.ConditionTrue,
							},
							{
								Type:   v1.NodePIDPressure,
								Status: v1.ConditionTrue,
							},
							{
								Type:   v1.NodeNetworkUnavailable,
								Status: v1.ConditionTrue,
							},
							{
								Type:   v1.NodeMemoryPressure,
								Status: v1.ConditionUnknown,
							},
							{
								Type:   v1.NodeDiskPressure,
								Status: v1.ConditionUnknown,
							},
							{
								Type:   v1.NodePIDPressure,
								Status: v1.ConditionUnknown,
							},
							{
								Type:   v1.NodeNetworkUnavailable,
								Status: v1.ConditionUnknown,
							},
							// A cloud provider may set their own condition and/or a new status
							// might be introduced. In such cases a failure is assumed and
							// the code shouldn't break, although it might be a false positive.
							{
								Type:   "UnknownNodeConditionType",
								Status: "CompletelyUnknown",
							},
							// These won't contribute to failures.
							{
								Type:   v1.NodeMemoryPressure,
								Status: v1.ConditionFalse,
							},
							{
								Type:   v1.NodeDiskPressure,
								Status: v1.ConditionFalse,
							},
							{
								Type:   v1.NodePIDPressure,
								Status: v1.ConditionFalse,
							},
							{
								Type:   v1.NodeNetworkUnavailable,
								Status: v1.ConditionFalse,
							},
						},
					},
				},
				&v1.Node{
					// A node without any failures shouldn't be present in the results.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Node3",
						Namespace: "test",
					},
					Status: v1.NodeStatus{
						Conditions: []v1.NodeCondition{
							{
								// Won't contribute to failures.
								Type:   v1.NodeReady,
								Status: v1.ConditionTrue,
							},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "test",
	}

	nAnalyzer := NodeAnalyzer{}
	results, err := nAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []struct {
		name          string
		failuresCount int
	}{
		{
			name:          "Node2",
			failuresCount: 11,
		},
	}

	require.Equal(t, len(expectations), len(results))

	for i, result := range results {
		require.Equal(t, expectations[i].name, result.Name)
		require.Equal(t, expectations[i].failuresCount, len(result.Error))
	}
}

func TestNodeAnalyzerLabelSelectorFiltering(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(&v1.Node{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "Node1",
					Namespace: "default",
					Labels: map[string]string{
						"app": "node",
					},
				},
				Status: v1.NodeStatus{
					Conditions: []v1.NodeCondition{
						{
							Type:   v1.NodeReady,
							Status: v1.ConditionFalse,
						},
					},
				},
			},
				&v1.Node{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Node2",
						Namespace: "default",
					},
					Status: v1.NodeStatus{
						Conditions: []v1.NodeCondition{
							{
								Type:   v1.NodeReady,
								Status: v1.ConditionFalse,
							},
						},
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=node",
	}

	nAnalyzer := NodeAnalyzer{}
	results, err := nAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "Node1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type PdbAnalyzer struct{}

func (PdbAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "PodDisruptionBudget"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "policy",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	list, err := a.Client.GetClient().PolicyV1().PodDisruptionBudgets(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, pdb := range list.Items {
		var failures []common.Failure

		// Before accessing the Conditions, check if they exist or not.
		if len(pdb.Status.Conditions) == 0 {
			continue
		}
		if pdb.Status.Conditions[0].Type == "DisruptionAllowed" && pdb.Status.Conditions[0].Status == "False" {
			var doc string
			if pdb.Spec.MaxUnavailable != nil {
				doc = apiDoc.GetApiDocV2("spec.maxUnavailable")
			}
			if pdb.Spec.MinAvailable != nil {
				doc = apiDoc.GetApiDocV2("spec.minAvailable")
			}
			if pdb.Spec.Selector != nil && pdb.Spec.Selector.MatchLabels != nil {
				for k, v := range pdb.Spec.Selector.MatchLabels {
					failures = append(failures, common.Failure{
						Text:          fmt.Sprintf("%s, expected pdb pod label %s=%s", pdb.Status.Conditions[0].Reason, k, v),
						KubernetesDoc: doc,
						Sensitive: []common.Sensitive{
							{
								Unmasked: k,
								Masked:   util.MaskString(k),
							},
							{
								Unmasked: v,
								Masked:   util.MaskString(v),
							},
						},
					})
				}
			}
		}

		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", pdb.Namespace, pdb.Name)] = common.PreAnalysis{
				PodDisruptionBudget: pdb,
				FailureDetails:      failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, pdb.Name, pdb.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.PodDisruptionBudget.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, err
}
/*
Copyright 2024 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	policyv1 "k8s.io/api/policy/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes/fake"
)

func TestPodDisruptionBudgetAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB1",
						Namespace: "test",
					},
					// Status conditions are nil.
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: nil,
					},
				},
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB2",
						Namespace: "test",
					},
					// Status conditions are empty.
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: []metav1.Condition{},
					},
				},
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB3",
						Namespace: "test",
					},
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: []metav1.Condition{
							{
								Type:   "DisruptionAllowed",
								Status: "False",
								Reason: "test reason",
							},
						},
					},
					Spec: policyv1.PodDisruptionBudgetSpec{
						MaxUnavailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 17,
							StrVal: "17",
						},
						MinAvailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 7,
							StrVal: "7",
						},
						// MatchLabels specified.
						Selector: &metav1.LabelSelector{
							MatchLabels: map[string]string{
								"label1": "test1",
								"label2": "test2",
							},
						},
					},
				},
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB4",
						Namespace: "test",
					},
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: []metav1.Condition{
							{
								Type:   "DisruptionAllowed",
								Status: "False",
								Reason: "test reason",
							},
						},
					},
					// Match Labels Empty.
					Spec: policyv1.PodDisruptionBudgetSpec{
						Selector: &metav1.LabelSelector{},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "test",
	}

	pdbAnalyzer := PdbAnalyzer{}
	results, err := pdbAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "test/PDB3", results[0].Name)
}

func TestPodDisruptionBudgetAnalyzerLabelSelectorFiltering(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "pdb",
						},
					},
					// Status conditions are nil.
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: []metav1.Condition{
							{
								Type:   "DisruptionAllowed",
								Status: "False",
								Reason: "test reason",
							},
						},
					},
					Spec: policyv1.PodDisruptionBudgetSpec{
						MaxUnavailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 17,
							StrVal: "17",
						},
						MinAvailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 7,
							StrVal: "7",
						},
						// MatchLabels specified.
						Selector: &metav1.LabelSelector{
							MatchLabels: map[string]string{
								"label1": "test1",
								"label2": "test2",
							},
						},
					},
				},
				&policyv1.PodDisruptionBudget{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PDB2",
						Namespace: "default",
					},
					// Status conditions are empty.
					Status: policyv1.PodDisruptionBudgetStatus{
						Conditions: []metav1.Condition{
							{
								Type:   "DisruptionAllowed",
								Status: "False",
								Reason: "test reason",
							},
						},
					},
					Spec: policyv1.PodDisruptionBudgetSpec{
						MaxUnavailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 17,
							StrVal: "17",
						},
						MinAvailable: &intstr.IntOrString{
							Type:   0,
							IntVal: 7,
							StrVal: "7",
						},
						// MatchLabels specified.
						Selector: &metav1.LabelSelector{
							MatchLabels: map[string]string{
								"label1": "test1",
								"label2": "test2",
							},
						},
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=pdb",
	}

	pdbAnalyzer := PdbAnalyzer{}
	results, err := pdbAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/PDB1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type PodAnalyzer struct {
}

func (PodAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Pod"

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// search all namespaces for pods that are not running
	list, err := a.Client.GetClient().CoreV1().Pods(a.Namespace).List(a.Context, metav1.ListOptions{
		LabelSelector: a.LabelSelector,
	})
	if err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	for _, pod := range list.Items {
		var failures []common.Failure

		// Check for pending pods
		if pod.Status.Phase == "Pending" {
			// Check through container status to check for crashes
			for _, containerStatus := range pod.Status.Conditions {
				if containerStatus.Type == v1.PodScheduled && containerStatus.Reason == "Unschedulable" {
					if containerStatus.Message != "" {
						failures = append(failures, common.Failure{
							Text:      containerStatus.Message,
							Sensitive: []common.Sensitive{},
						})
					}
				}
			}
		}

		// Check for errors in the init containers.
		failures = append(failures, analyzeContainerStatusFailures(a, pod.Status.InitContainerStatuses, pod.Name, pod.Namespace, string(pod.Status.Phase))...)

		// Check for errors in containers.
		failures = append(failures, analyzeContainerStatusFailures(a, pod.Status.ContainerStatuses, pod.Name, pod.Namespace, string(pod.Status.Phase))...)

		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", pod.Namespace, pod.Name)] = common.PreAnalysis{
				Pod:            pod,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, pod.Name, pod.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.Pod.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}

func analyzeContainerStatusFailures(a common.Analyzer, statuses []v1.ContainerStatus, name string, namespace string, statusPhase string) []common.Failure {
	var failures []common.Failure

	// Check through container status to check for crashes or unready
	for _, containerStatus := range statuses {
		if containerStatus.State.Waiting != nil {
			if containerStatus.State.Waiting.Reason == "ContainerCreating" && statusPhase == "Pending" {
				// This represents a container that is still being created or blocked due to conditions such as OOMKilled
				// parse the event log and append details
				evt, err := util.FetchLatestEvent(a.Context, a.Client, namespace, name)
				if err != nil || evt == nil {
					continue
				}
				if isEvtErrorReason(evt.Reason) && evt.Message != "" {
					failures = append(failures, common.Failure{
						Text:      evt.Message,
						Sensitive: []common.Sensitive{},
					})
				}
			} else if containerStatus.State.Waiting.Reason == "CrashLoopBackOff" && containerStatus.LastTerminationState.Terminated != nil {
				// This represents container that is in CrashLoopBackOff state due to conditions such as OOMKilled
				failures = append(failures, common.Failure{
					Text:      fmt.Sprintf("the last termination reason is %s container=%s pod=%s", containerStatus.LastTerminationState.Terminated.Reason, containerStatus.Name, name),
					Sensitive: []common.Sensitive{},
				})
			} else if isErrorReason(containerStatus.State.Waiting.Reason) && containerStatus.State.Waiting.Message != "" {
				failures = append(failures, common.Failure{
					Text:      containerStatus.State.Waiting.Message,
					Sensitive: []common.Sensitive{},
				})
			}
		} else {
			// when pod is Running but its ReadinessProbe fails
			if !containerStatus.Ready && statusPhase == "Running" {
				// parse the event log and append details
				evt, err := util.FetchLatestEvent(a.Context, a.Client, namespace, name)
				if err != nil || evt == nil {
					continue
				}
				if evt.Reason == "Unhealthy" && evt.Message != "" {
					failures = append(failures, common.Failure{
						Text:      evt.Message,
						Sensitive: []common.Sensitive{},
					})
				}
			}
		}
	}

	return failures
}

func isErrorReason(reason string) bool {
	failureReasons := []string{
		"CrashLoopBackOff", "ImagePullBackOff", "CreateContainerConfigError", "PreCreateHookError", "CreateContainerError",
		"PreStartHookError", "RunContainerError", "ImageInspectError", "ErrImagePull", "ErrImageNeverPull", "InvalidImageName",
	}

	for _, r := range failureReasons {
		if r == reason {
			return true
		}
	}
	return false
}

func isEvtErrorReason(reason string) bool {
	failureReasons := []string{
		"FailedCreatePodSandBox", "FailedMount",
	}

	for _, r := range failureReasons {
		if r == reason {
			return true
		}
	}
	return false
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestPodAnalyzer(t *testing.T) {
	tests := []struct {
		name         string
		config       common.Analyzer
		expectations []struct {
			name          string
			failuresCount int
		}
	}{
		{
			name: "Pending pods, namespace filtering and readiness probe failure",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod1",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								Phase: v1.PodPending,
								Conditions: []v1.PodCondition{
									{
										// This condition will contribute to failures.
										Type:    v1.PodScheduled,
										Reason:  "Unschedulable",
										Message: "0/1 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate.",
									},
									{
										// This condition won't contribute to failures.
										Type:   v1.PodScheduled,
										Reason: "Unexpected failure",
									},
								},
							},
						},
						&v1.Pod{
							// This pod won't be selected because of namespace filtering.
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod2",
								Namespace: "test",
							},
						},
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod3",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								// When pod is Running but its ReadinessProbe fails
								Phase: v1.PodRunning,
								ContainerStatuses: []v1.ContainerStatus{
									{
										Ready: false,
									},
								},
							},
						},
						&v1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							InvolvedObject: v1.ObjectReference{
								Kind:      "Pod",
								Name:      "Pod3",
								Namespace: "default",
							},
							Reason:  "Unhealthy",
							Message: "readiness probe failed: the detail reason here ...",
							Source:  v1.EventSource{Component: "eventTest"},
							Count:   1,
							Type:    v1.EventTypeWarning,
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
			expectations: []struct {
				name          string
				failuresCount int
			}{
				{
					name:          "default/Pod1",
					failuresCount: 1,
				},
				{
					name:          "default/Pod3",
					failuresCount: 1,
				},
			},
		},
		{
			name: "readiness probe failure without any event",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod1",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								// When pod is Running but its ReadinessProbe fails
								// It won't contribute to any failures because
								// there's no event present.
								Phase: v1.PodRunning,
								ContainerStatuses: []v1.ContainerStatus{
									{
										Ready: false,
									},
								},
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
		},
		{
			name: "Init container status state waiting",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod1",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								Phase: v1.PodPending,
								InitContainerStatuses: []v1.ContainerStatus{
									{
										Ready: true,
										State: v1.ContainerState{
											Running: &v1.ContainerStateRunning{
												StartedAt: metav1.Now(),
											},
										},
									},
									{
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// This represents a container that is still being created or blocked due to conditions such as OOMKilled
												Reason: "ContainerCreating",
											},
										},
									},
								},
							},
						},
						&v1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							InvolvedObject: v1.ObjectReference{
								Kind:      "Pod",
								Name:      "Pod1",
								Namespace: "default",
							},
							Reason:  "FailedCreatePodSandBox",
							Message: "failed to create the pod sandbox ...",
							Type:    v1.EventTypeWarning,
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
			expectations: []struct {
				name          string
				failuresCount int
			}{
				{
					name:          "default/Pod1",
					failuresCount: 1,
				},
			},
		},
		{
			name: "Container status state waiting but no event reported",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod1",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								Phase: v1.PodPending,
								ContainerStatuses: []v1.ContainerStatus{
									{
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// This represents a container that is still being created or blocked due to conditions such as OOMKilled
												Reason: "ContainerCreating",
											},
										},
									},
								},
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
		},
		{
			name: "Container status state waiting",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&v1.Pod{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Pod1",
								Namespace: "default",
							},
							Status: v1.PodStatus{
								Phase: v1.PodPending,
								ContainerStatuses: []v1.ContainerStatus{
									{
										Name:  "Container1",
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// This represents a container that is still being created or blocked due to conditions such as OOMKilled
												Reason: "ContainerCreating",
											},
										},
									},
									{
										Name:  "Container2",
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// This represents container that is in CrashLoopBackOff state due to conditions such as OOMKilled
												Reason: "CrashLoopBackOff",
											},
										},
										LastTerminationState: v1.ContainerState{
											Terminated: &v1.ContainerStateTerminated{
												Reason: "test reason",
											},
										},
									},
									{
										Name:  "Container3",
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// This won't contribute to failures.
												Reason:  "RandomReason",
												Message: "This container won't be present in the failures",
											},
										},
									},
									{
										Name:  "Container4",
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// Valid error reason.
												Reason:  "PreStartHookError",
												Message: "Container4 encountered PreStartHookError",
											},
										},
									},
									{
										Name:  "Container5",
										Ready: false,
										State: v1.ContainerState{
											Waiting: &v1.ContainerStateWaiting{
												// Valid error reason.
												Reason:  "CrashLoopBackOff",
												Message: "Container4 encountered CrashLoopBackOff",
											},
										},
									},
								},
							},
						},
						&v1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							InvolvedObject: v1.ObjectReference{
								Kind:      "Pod",
								Name:      "Pod1",
								Namespace: "default",
							},
							// This reason won't contribute to failures.
							Reason: "RandomEvent",
							Type:   v1.EventTypeWarning,
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
			expectations: []struct {
				name          string
				failuresCount int
			}{
				{
					name:          "default/Pod1",
					failuresCount: 3,
				},
			},
		},
	}

	podAnalyzer := PodAnalyzer{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			results, err := podAnalyzer.Analyze(tt.config)
			require.NoError(t, err)

			if tt.expectations == nil {
				require.Equal(t, 0, len(results))
			} else {
				sort.Slice(results, func(i, j int) bool {
					return results[i].Name < results[j].Name
				})

				require.Equal(t, len(tt.expectations), len(results))

				for i, result := range results {
					require.Equal(t, tt.expectations[i].name, result.Name)
					require.Equal(t, tt.expectations[i].failuresCount, len(result.Error))
				}
			}
		})
	}
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	appsv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type PvcAnalyzer struct{}

func (PvcAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "PersistentVolumeClaim"

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// search all namespaces for pods that are not running
	list, err := a.Client.GetClient().CoreV1().PersistentVolumeClaims(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, pvc := range list.Items {
		var failures []common.Failure

		// Check for empty rs
		if pvc.Status.Phase == appsv1.ClaimPending {

			// parse the event log and append details
			evt, err := util.FetchLatestEvent(a.Context, a.Client, pvc.Namespace, pvc.Name)
			if err != nil || evt == nil {
				continue
			}
			if evt.Reason == "ProvisioningFailed" && evt.Message != "" {
				failures = append(failures, common.Failure{
					Text:      evt.Message,
					Sensitive: []common.Sensitive{},
				})
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", pvc.Namespace, pvc.Name)] = common.PreAnalysis{
				PersistentVolumeClaim: pvc,
				FailureDetails:        failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, pvc.Name, pvc.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.PersistentVolumeClaim.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2024 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"
	"time"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	appsv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestPersistentVolumeClaimAnalyzer(t *testing.T) {
	tests := []struct {
		name         string
		config       common.Analyzer
		expectations []string
	}{
		{
			name: "PV1 and PVC5 report failures",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&appsv1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							LastTimestamp: metav1.Time{
								Time: time.Date(2024, 3, 15, 10, 0, 0, 0, time.UTC),
							},
							Reason:  "ProvisioningFailed",
							Message: "PVC Event1 provisioning failed",
						},
						&appsv1.Event{
							ObjectMeta: metav1.ObjectMeta{
								// This event won't get selected.
								Name:      "Event2",
								Namespace: "test",
							},
						},
						&appsv1.Event{
							// This is the latest event.
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event3",
								Namespace: "default",
							},
							LastTimestamp: metav1.Time{
								Time: time.Date(2024, 4, 15, 10, 0, 0, 0, time.UTC),
							},
							Reason:  "ProvisioningFailed",
							Message: "PVC Event3 provisioning failed",
						},
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC1",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimPending,
							},
						},
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC2",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								// Won't contribute to failures.
								Phase: appsv1.ClaimBound,
							},
						},
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC3",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								// Won't contribute to failures.
								Phase: appsv1.ClaimLost,
							},
						},
						&appsv1.PersistentVolumeClaim{
							// PVCs in namespace other than "default" won't be discovered.
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC4",
								Namespace: "test",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimLost,
							},
						},
						&appsv1.PersistentVolumeClaim{
							// PVCs in namespace other than "default" won't be discovered.
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC5",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimPending,
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
			expectations: []string{
				"default/PVC1",
				"default/PVC5",
			},
		},
		{
			name: "no event",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC1",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimPending,
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
		},
		{
			name: "event other than provision failure",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&appsv1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							// Any reason other than ProvisioningFailed won't result in failure.
							Reason: "UnknownReason",
						},
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC1",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimPending,
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
		},
		{
			name: "event without error message",
			config: common.Analyzer{
				Client: &kubernetes.Client{
					Client: fake.NewSimpleClientset(
						&appsv1.Event{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "Event1",
								Namespace: "default",
							},
							// Event without any error message won't result in failure.
							Reason: "ProvisioningFailed",
						},
						&appsv1.PersistentVolumeClaim{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "PVC1",
								Namespace: "default",
							},
							Status: appsv1.PersistentVolumeClaimStatus{
								Phase: appsv1.ClaimPending,
							},
						},
					),
				},
				Context:   context.Background(),
				Namespace: "default",
			},
		},
	}

	pvcAnalyzer := PvcAnalyzer{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			results, err := pvcAnalyzer.Analyze(tt.config)
			require.NoError(t, err)

			if tt.expectations == nil {
				require.Equal(t, 0, len(results))
			} else {
				sort.Slice(results, func(i, j int) bool {
					return results[i].Name < results[j].Name
				})

				require.Equal(t, len(tt.expectations), len(results))

				for i, expectation := range tt.expectations {
					require.Equal(t, expectation, results[i].Name)
				}
			}
		})
	}
}

func TestPvcAnalyzerLabelSelectorFiltering(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&appsv1.Event{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Event1",
						Namespace: "default",
					},
					LastTimestamp: metav1.Time{
						Time: time.Date(2024, 3, 15, 10, 0, 0, 0, time.UTC),
					},
					Reason:  "ProvisioningFailed",
					Message: "PVC Event1 provisioning failed",
				},
				&appsv1.PersistentVolumeClaim{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PVC1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "pvc",
						},
					},
					Status: appsv1.PersistentVolumeClaimStatus{
						Phase: appsv1.ClaimPending,
					},
				},
				&appsv1.PersistentVolumeClaim{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "PVC2",
						Namespace: "default",
					},
					Status: appsv1.PersistentVolumeClaimStatus{
						Phase: appsv1.ClaimPending,
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=pvc",
	}

	pvcAnalyzer := PvcAnalyzer{}
	results, err := pvcAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/PVC1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ReplicaSetAnalyzer struct{}

func (ReplicaSetAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "ReplicaSet"

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// search all namespaces for pods that are not running
	list, err := a.Client.GetClient().AppsV1().ReplicaSets(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, rs := range list.Items {
		var failures []common.Failure

		// Check for empty rs
		if rs.Status.Replicas == 0 {

			// Check through container status to check for crashes
			for _, rsStatus := range rs.Status.Conditions {
				if rsStatus.Type == "ReplicaFailure" && rsStatus.Reason == "FailedCreate" {
					failures = append(failures, common.Failure{
						Text:      rsStatus.Message,
						Sensitive: []common.Sensitive{},
					})

				}
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", rs.Namespace, rs.Name)] = common.PreAnalysis{
				ReplicaSet:     rs,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, rs.Name, rs.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.ReplicaSet.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}
	return a.Results, nil
}
/*
Copyright 2024 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestReplicaSetAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&appsv1.ReplicaSet{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet1",
						Namespace: "default",
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 0,
						Conditions: []appsv1.ReplicaSetCondition{
							{
								// Should contribute to failures.
								Type:    appsv1.ReplicaSetReplicaFailure,
								Reason:  "FailedCreate",
								Message: "failed to create test replica set 1",
							},
						},
					},
				},
				&appsv1.ReplicaSet{
					// This replicaset won't be discovered as it is not in the
					// default namespace.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet2",
						Namespace: "test",
					},
				},
				&appsv1.ReplicaSet{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet3",
						Namespace: "default",
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 0,
						Conditions: []appsv1.ReplicaSetCondition{
							{
								Type: appsv1.ReplicaSetReplicaFailure,
								// Should not be included in the failures.
								Reason: "RandomError",
							},
						},
					},
				},
				&appsv1.ReplicaSet{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet4",
						Namespace: "default",
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 0,
						Conditions: []appsv1.ReplicaSetCondition{
							{
								// Should contribute to failures.
								Type:    appsv1.ReplicaSetReplicaFailure,
								Reason:  "FailedCreate",
								Message: "failed to create test replica set 4 condition 1",
							},
							{
								// Should not contribute to failures.
								Type:   appsv1.ReplicaSetReplicaFailure,
								Reason: "Unknown",
							},
							{
								// Should not contribute to failures.
								Type:    appsv1.ReplicaSetReplicaFailure,
								Reason:  "FailedCreate",
								Message: "failed to create test replica set 4 condition 3",
							},
						},
					},
				},
				&appsv1.ReplicaSet{
					// Replicaset without any failures.
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet5",
						Namespace: "default",
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 3,
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	rsAnalyzer := ReplicaSetAnalyzer{}
	results, err := rsAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []struct {
		name          string
		failuresCount int
	}{
		{
			name:          "default/ReplicaSet1",
			failuresCount: 1,
		},
		{
			name:          "default/ReplicaSet4",
			failuresCount: 2,
		},
	}

	require.Equal(t, len(expectations), len(results))

	for i, result := range results {
		require.Equal(t, expectations[i].name, result.Name)
		require.Equal(t, expectations[i].failuresCount, len(result.Error))
	}
}

func TestReplicaSetAnalyzerLabelSelectorFiltering(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&appsv1.ReplicaSet{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet1",
						Namespace: "default",
						Labels: map[string]string{
							"app": "replicaset",
						},
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 0,
						Conditions: []appsv1.ReplicaSetCondition{
							{
								// Should contribute to failures.
								Type:    appsv1.ReplicaSetReplicaFailure,
								Reason:  "FailedCreate",
								Message: "failed to create test replica set 1",
							},
						},
					},
				},
				&appsv1.ReplicaSet{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "ReplicaSet2",
						Namespace: "default",
					},
					Status: appsv1.ReplicaSetStatus{
						Replicas: 0,
						Conditions: []appsv1.ReplicaSetCondition{
							{
								// Should contribute to failures.
								Type:    appsv1.ReplicaSetReplicaFailure,
								Reason:  "FailedCreate",
								Message: "failed to create test replica set 1",
							},
						},
					},
				},
			),
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=replicaset",
	}

	rsAnalyzer := ReplicaSetAnalyzer{}
	results, err := rsAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/ReplicaSet1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/fatih/color"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/tools/leaderelection/resourcelock"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type ServiceAnalyzer struct{}

func (ServiceAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "Service"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	// search all namespaces for pods that are not running
	list, err := a.Client.GetClient().CoreV1().Endpoints(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}

	var preAnalysis = map[string]common.PreAnalysis{}

	for _, ep := range list.Items {
		var failures []common.Failure

		// Check for empty service
		if len(ep.Subsets) == 0 {
			if _, ok := ep.Annotations[resourcelock.LeaderElectionRecordAnnotationKey]; ok {
				continue
			}

			svc, err := a.Client.GetClient().CoreV1().Services(ep.Namespace).Get(a.Context, ep.Name, metav1.GetOptions{})
			if err != nil {
				color.Yellow("Service %s/%s does not exist", ep.Namespace, ep.Name)
				continue
			}

			for k, v := range svc.Spec.Selector {
				doc := apiDoc.GetApiDocV2("spec.selector")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Service has no endpoints, expected label %s=%s", k, v),
					KubernetesDoc: doc,
					Sensitive: []common.Sensitive{
						{
							Unmasked: k,
							Masked:   util.MaskString(k),
						},
						{
							Unmasked: v,
							Masked:   util.MaskString(v),
						},
					},
				})
			}
		} else {
			count := 0
			pods := []string{}

			// Check through container status to check for crashes
			for _, epSubset := range ep.Subsets {
				apiDoc.Kind = "Endpoints"

				if len(epSubset.NotReadyAddresses) > 0 {
					for _, addresses := range epSubset.NotReadyAddresses {
						count++
						pods = append(pods, addresses.TargetRef.Kind+"/"+addresses.TargetRef.Name)
					}
				}
			}

			if count > 0 {
				doc := apiDoc.GetApiDocV2("subsets.notReadyAddresses")

				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Service has not ready endpoints, pods: %s, expected %d", pods, count),
					KubernetesDoc: doc,
					Sensitive:     []common.Sensitive{},
				})
			}
		}
		// fetch event
		events, err := a.Client.GetClient().CoreV1().Events(a.Namespace).List(a.Context,
			metav1.ListOptions{
				FieldSelector: "involvedObject.name=" + ep.Name,
			})

		if err != nil {
			return nil, err
		}
		for _, event := range events.Items {
			if event.Type != "Normal" {
				failures = append(failures, common.Failure{
					Text: fmt.Sprintf("Service %s/%s has event %s", ep.Namespace, ep.Name, event.Message),
				})
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", ep.Namespace, ep.Name)] = common.PreAnalysis{
				Endpoint:       ep,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, ep.Name, ep.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.Endpoint.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}
	return a.Results, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"sort"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
	"k8s.io/client-go/tools/leaderelection/resourcelock"
)

func TestServiceAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Endpoints{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Endpoint1",
						Namespace: "test",
					},
					// Endpoint with non-zero subsets.
					Subsets: []v1.EndpointSubset{
						{
							// These not ready end points will contribute to failures.
							NotReadyAddresses: []v1.EndpointAddress{
								{
									TargetRef: &v1.ObjectReference{
										Kind: "test-reference",
										Name: "reference1",
									},
								},
								{
									TargetRef: &v1.ObjectReference{
										Kind: "test-reference",
										Name: "reference2",
									},
								},
							},
						},
						{
							// These not ready end points will contribute to failures.
							NotReadyAddresses: []v1.EndpointAddress{
								{
									TargetRef: &v1.ObjectReference{
										Kind: "test-reference",
										Name: "reference3",
									},
								},
							},
						},
					},
				},
				&v1.Endpoints{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Endpoint2",
						Namespace: "test",
						Annotations: map[string]string{
							// Leader election record annotation key defined.
							resourcelock.LeaderElectionRecordAnnotationKey: "this is okay",
						},
					},
					// Endpoint with zero subsets.
				},
				&v1.Endpoints{
					ObjectMeta: metav1.ObjectMeta{
						// This won't contribute to any failures.
						Name:        "non-existent-service",
						Namespace:   "test",
						Annotations: map[string]string{},
					},
					// Endpoint with zero subsets.
				},
				&v1.Endpoints{
					ObjectMeta: metav1.ObjectMeta{
						Name:        "Service1",
						Namespace:   "test",
						Annotations: map[string]string{},
					},
					// Endpoint with zero subsets.
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Service1",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						Selector: map[string]string{
							"app1": "test-app1",
							"app2": "test-app2",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						// This service won't be discovered.
						Name:      "Service2",
						Namespace: "default",
					},
					Spec: v1.ServiceSpec{
						Selector: map[string]string{
							"app1": "test-app1",
							"app2": "test-app2",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Service3",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						// No Spec Selector
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "test",
	}

	sAnalyzer := ServiceAnalyzer{}
	results, err := sAnalyzer.Analyze(config)
	require.NoError(t, err)

	sort.Slice(results, func(i, j int) bool {
		return results[i].Name < results[j].Name
	})

	expectations := []struct {
		name          string
		failuresCount int
	}{
		{
			name:          "test/Endpoint1",
			failuresCount: 1,
		},
		{
			name:          "test/Service1",
			failuresCount: 2,
		},
	}

	require.Equal(t, len(expectations), len(results))

	for i, result := range results {
		require.Equal(t, expectations[i].name, result.Name)
		require.Equal(t, expectations[i].failuresCount, len(result.Error))
	}
}

func TestServiceAnalyzerLabelSelectorFiltering(t *testing.T) {
	clientSet :=
		fake.NewSimpleClientset(
			&v1.Endpoints{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "Endpoint1",
					Namespace: "default",
					Labels: map[string]string{
						"app":     "service",
						"part-of": "test",
					},
				},
				// Endpoint with non-zero subsets.
				Subsets: []v1.EndpointSubset{
					{
						// These not ready end points will contribute to failures.
						NotReadyAddresses: []v1.EndpointAddress{
							{
								TargetRef: &v1.ObjectReference{
									Kind: "test-reference",
									Name: "reference1",
								},
							},
							{
								TargetRef: &v1.ObjectReference{
									Kind: "test-reference",
									Name: "reference2",
								},
							},
						},
					},
					{
						// These not ready end points will contribute to failures.
						NotReadyAddresses: []v1.EndpointAddress{
							{
								TargetRef: &v1.ObjectReference{
									Kind: "test-reference",
									Name: "reference3",
								},
							},
						},
					},
				},
			},
			&v1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "Service1",
					Namespace: "default",
					Labels: map[string]string{
						"app": "service",
					},
				},
				Spec: v1.ServiceSpec{
					Selector: map[string]string{
						"app1": "test-app1",
						"app2": "test-app2",
					},
				},
			},
			&v1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "Service2",
					Namespace: "default",
				},
				Spec: v1.ServiceSpec{
					Selector: map[string]string{
						"app1": "test-app1",
						"app2": "test-app2",
					},
				},
			},
		)
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=service",
	}

	sAnalyzer := ServiceAnalyzer{}
	results, err := sAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/Endpoint1", results[0].Name)

	config = common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=service,part-of=test",
	}

	sAnalyzer = ServiceAnalyzer{}
	results, err = sAnalyzer.Analyze(config)
	require.NoError(t, err)
	require.Equal(t, 1, len(results))
	require.Equal(t, "default/Endpoint1", results[0].Name)
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type StatefulSetAnalyzer struct{}

func (StatefulSetAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "StatefulSet"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "apps",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	list, err := a.Client.GetClient().AppsV1().StatefulSets(a.Namespace).List(a.Context, metav1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	for _, sts := range list.Items {
		var failures []common.Failure

		// get serviceName
		serviceName := sts.Spec.ServiceName
		_, err := a.Client.GetClient().CoreV1().Services(sts.Namespace).Get(a.Context, serviceName, metav1.GetOptions{})
		if err != nil {
			doc := apiDoc.GetApiDocV2("spec.serviceName")

			failures = append(failures, common.Failure{
				Text: fmt.Sprintf(
					"StatefulSet uses the service %s/%s which does not exist.",
					sts.Namespace,
					serviceName,
				),
				KubernetesDoc: doc,
				Sensitive: []common.Sensitive{
					{
						Unmasked: sts.Namespace,
						Masked:   util.MaskString(sts.Namespace),
					},
					{
						Unmasked: serviceName,
						Masked:   util.MaskString(serviceName),
					},
				},
			})
		}
		if len(sts.Spec.VolumeClaimTemplates) > 0 {
			for _, volumeClaimTemplate := range sts.Spec.VolumeClaimTemplates {
				if volumeClaimTemplate.Spec.StorageClassName != nil {
					_, err := a.Client.GetClient().StorageV1().StorageClasses().Get(a.Context, *volumeClaimTemplate.Spec.StorageClassName, metav1.GetOptions{})
					if err != nil {
						failures = append(failures, common.Failure{
							Text: fmt.Sprintf("StatefulSet uses the storage class %s which does not exist.", *volumeClaimTemplate.Spec.StorageClassName),
							Sensitive: []common.Sensitive{
								{
									Unmasked: *volumeClaimTemplate.Spec.StorageClassName,
									Masked:   util.MaskString(*volumeClaimTemplate.Spec.StorageClassName),
								},
							},
						})
					}
				}
			}
		}
		if sts.Spec.Replicas != nil && *(sts.Spec.Replicas) != sts.Status.AvailableReplicas {
			for i := int32(0); i < *(sts.Spec.Replicas); i++ {
				podName := sts.Name + "-" + fmt.Sprint(i)
				pod, err := a.Client.GetClient().CoreV1().Pods(sts.Namespace).Get(a.Context, podName, metav1.GetOptions{})
				if err != nil {
					if errors.IsNotFound(err) && i == 0 {
						evt, err := util.FetchLatestEvent(a.Context, a.Client, sts.Namespace, sts.Name)
						if err != nil || evt == nil || evt.Type == "Normal" {
							break
						}
						failures = append(failures, common.Failure{
							Text:      evt.Message,
							Sensitive: []common.Sensitive{},
						})
					}
					break
				}
				if pod.Status.Phase != "Running" {
					failures = append(failures, common.Failure{
						Text: fmt.Sprintf("Statefulset pod %s in the namespace %s is not in running state.", pod.Name, pod.Namespace),
						Sensitive: []common.Sensitive{
							{
								Unmasked: sts.Namespace,
								Masked:   util.MaskString(pod.Name),
							},
							{
								Unmasked: serviceName,
								Masked:   util.MaskString(pod.Namespace),
							},
						},
					})
					break
				}
			}
		}
		if len(failures) > 0 {
			preAnalysis[fmt.Sprintf("%s/%s", sts.Namespace, sts.Name)] = common.PreAnalysis{
				StatefulSet:    sts,
				FailureDetails: failures,
			}
			AnalyzerErrorsMetric.WithLabelValues(kind, sts.Name, sts.Namespace).Set(float64(len(failures)))
		}
	}

	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.StatefulSet.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/magiconair/properties/assert"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestStatefulSetAnalyzer(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
		})
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestStatefulSetAnalyzerWithoutService(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.StatefulSetSpec{
				ServiceName: "example-svc",
			},
		})
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	var errorFound bool
	want := "StatefulSet uses the service default/example-svc which does not exist."

	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}
	if !errorFound {
		t.Errorf("Error expected: '%v', not found in StatefulSet's analysis results", want)
	}
}

func TestStatefulSetAnalyzerMissingStorageClass(t *testing.T) {
	storageClassName := "example-sc"
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.StatefulSetSpec{
				ServiceName: "example-svc",
				VolumeClaimTemplates: []corev1.PersistentVolumeClaim{
					{
						TypeMeta: metav1.TypeMeta{
							Kind:       "PersistentVolumeClaim",
							APIVersion: "v1",
						},
						ObjectMeta: metav1.ObjectMeta{
							Name: "pvc-example",
						},
						Spec: corev1.PersistentVolumeClaimSpec{
							StorageClassName: &storageClassName,
							AccessModes: []corev1.PersistentVolumeAccessMode{
								"ReadWriteOnce",
							},
							Resources: corev1.VolumeResourceRequirements{
								Requests: corev1.ResourceList{
									corev1.ResourceStorage: resource.MustParse("1Gi"),
								},
							},
						},
					},
				},
			},
		})
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	var errorFound bool
	want := "StatefulSet uses the storage class example-sc which does not exist."

	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}
	if !errorFound {
		t.Errorf("Error expected: '%v', not found in StatefulSet's analysis results", want)
	}

}

func TestStatefulSetAnalyzerNamespaceFiltering(t *testing.T) {
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
		},
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "other-namespace",
			},
		})
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestStatefulSetAnalyzerLabelSelectorFiltering(t *testing.T) {
	clientSet := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example1",
				Namespace: "default",
				Labels: map[string]string{
					"app":     "statefulset",
					"part-of": "test",
				},
			},
		},
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example2",
				Namespace: "default",
			},
		},
	)
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=statefulset",
	}
	statefulSetAnalyzer := StatefulSetAnalyzer{}
	results, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, 1, len(results))
	assert.Equal(t, "default/example1", results[0].Name)

	config = common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=statefulset,part-of=test",
	}
	statefulSetAnalyzer = StatefulSetAnalyzer{}
	results, err = statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, 1, len(results))
	assert.Equal(t, "default/example1", results[0].Name)
}

func TestStatefulSetAnalyzerReplica(t *testing.T) {
	replicas := int32(3)
	pods := []*corev1.Pod{
		{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example-0",
				Namespace: "default",
			},
			Status: corev1.PodStatus{
				Phase: corev1.PodRunning,
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example-1",
				Namespace: "default",
			},
			Status: corev1.PodStatus{
				Phase: corev1.PodRunning,
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example-2",
				Namespace: "default",
			},
			Status: corev1.PodStatus{
				Phase: corev1.PodRunning,
			},
		},
	}
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.StatefulSetSpec{
				Replicas: &replicas,
			},
			Status: appsv1.StatefulSetStatus{
				AvailableReplicas: 3,
			},
		},
		pods[0], pods[1], pods[2],
	)
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestStatefulSetAnalyzerUnavailableReplicas(t *testing.T) {
	replicas := int32(3)
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.StatefulSetSpec{
				Replicas: &replicas,
			},
			Status: appsv1.StatefulSetStatus{
				AvailableReplicas: 0,
			},
		})
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, len(analysisResults), 1)
}

func TestStatefulSetAnalyzerUnavailableReplicaWithPodInitialized(t *testing.T) {
	replicas := int32(3)
	pods := []*corev1.Pod{
		{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example-0",
				Namespace: "default",
			},
			Status: corev1.PodStatus{
				Phase: corev1.PodRunning,
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example-1",
				Namespace: "default",
			},
			Status: corev1.PodStatus{
				Phase: corev1.PodPending,
			},
		},
	}
	clientset := fake.NewSimpleClientset(
		&appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "example",
				Namespace: "default",
			},
			Spec: appsv1.StatefulSetSpec{
				Replicas: &replicas,
			},
			Status: appsv1.StatefulSetStatus{
				AvailableReplicas: 1,
			},
		},
		pods[0], pods[1],
	)
	statefulSetAnalyzer := StatefulSetAnalyzer{}

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientset,
		},
		Context:   context.Background(),
		Namespace: "default",
	}
	analysisResults, err := statefulSetAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}

	var errorFound bool
	want := "Statefulset pod example-1 in the namespace default is not in running state."

	for _, analysis := range analysisResults {
		for _, got := range analysis.Error {
			if want == got.Text {
				errorFound = true
			}
		}
		if errorFound {
			break
		}
	}
	if !errorFound {
		t.Errorf("Error expected: '%v', not found in StatefulSet's analysis results", want)
	}
}
/*
Copyright 2023 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"fmt"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/k8sgpt-ai/k8sgpt/pkg/util"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type ValidatingWebhookAnalyzer struct{}

func (ValidatingWebhookAnalyzer) Analyze(a common.Analyzer) ([]common.Result, error) {

	kind := "ValidatingWebhookConfiguration"
	apiDoc := kubernetes.K8sApiReference{
		Kind: kind,
		ApiVersion: schema.GroupVersion{
			Group:   "apps",
			Version: "v1",
		},
		OpenapiSchema: a.OpenapiSchema,
	}

	AnalyzerErrorsMetric.DeletePartialMatch(map[string]string{
		"analyzer_name": kind,
	})

	validatingWebhooks, err := a.Client.GetClient().AdmissionregistrationV1().ValidatingWebhookConfigurations().List(context.Background(), v1.ListOptions{LabelSelector: a.LabelSelector})
	if err != nil {
		return nil, err
	}
	var preAnalysis = map[string]common.PreAnalysis{}

	for _, webhookConfig := range validatingWebhooks.Items {
		for _, webhook := range webhookConfig.Webhooks {
			var failures []common.Failure
			if webhook.ClientConfig.Service == nil {
				continue
			}
			svc := webhook.ClientConfig.Service
			// Get the service
			service, err := a.Client.GetClient().CoreV1().Services(svc.Namespace).Get(context.Background(), svc.Name, v1.GetOptions{})
			if err != nil {
				// If the service is not found, we can't check the pods
				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("Service %s not found as mapped to by Validating Webhook %s", svc.Name, webhook.Name),
					KubernetesDoc: apiDoc.GetApiDocV2("spec.webhook.clientConfig.service"),
					Sensitive: []common.Sensitive{
						{
							Unmasked: webhookConfig.Namespace,
							Masked:   util.MaskString(webhookConfig.Namespace),
						},
						{
							Unmasked: svc.Name,
							Masked:   util.MaskString(svc.Name),
						},
					},
				})
				preAnalysis[fmt.Sprintf("%s/%s", webhookConfig.Namespace, webhook.Name)] = common.PreAnalysis{
					ValidatingWebhook: webhookConfig,
					FailureDetails:    failures,
				}
				AnalyzerErrorsMetric.WithLabelValues(kind, webhook.Name, webhookConfig.Namespace).Set(float64(len(failures)))
				continue
			}

			// When Service selectors are empty we defer to service analyser
			if len(service.Spec.Selector) == 0 {
				continue
			}
			// Get pods within service
			pods, err := a.Client.GetClient().CoreV1().Pods(svc.Namespace).List(context.Background(), v1.ListOptions{
				LabelSelector: util.MapToString(service.Spec.Selector),
			})
			if err != nil {
				return nil, err
			}

			if len(pods.Items) == 0 {
				failures = append(failures, common.Failure{
					Text:          fmt.Sprintf("No active pods found within service %s as mapped to by Validating Webhook %s", svc.Name, webhook.Name),
					KubernetesDoc: apiDoc.GetApiDocV2("spec.webhook.clientConfig.service"),
					Sensitive: []common.Sensitive{
						{
							Unmasked: webhookConfig.Namespace,
							Masked:   util.MaskString(webhookConfig.Namespace),
						},
					},
				})

			}
			for _, pod := range pods.Items {
				if pod.Status.Phase != "Running" {
					doc := apiDoc.GetApiDocV2("spec.webhook")
					failures = append(failures, common.Failure{
						Text: fmt.Sprintf(
							"Validating Webhook (%s) is pointing to an inactive receiver pod (%s)",
							webhook.Name,
							pod.Name,
						),
						KubernetesDoc: doc,
						Sensitive: []common.Sensitive{
							{
								Unmasked: webhookConfig.Namespace,
								Masked:   util.MaskString(webhookConfig.Namespace),
							},
							{
								Unmasked: webhook.Name,
								Masked:   util.MaskString(webhook.Name),
							},
							{
								Unmasked: pod.Name,
								Masked:   util.MaskString(pod.Name),
							},
						},
					})
				}
			}
			if len(failures) > 0 {
				preAnalysis[fmt.Sprintf("%s/%s", webhookConfig.Namespace, webhook.Name)] = common.PreAnalysis{
					ValidatingWebhook: webhookConfig,
					FailureDetails:    failures,
				}
				AnalyzerErrorsMetric.WithLabelValues(kind, webhook.Name, webhookConfig.Namespace).Set(float64(len(failures)))
			}
		}
	}
	for key, value := range preAnalysis {
		var currentAnalysis = common.Result{
			Kind:  kind,
			Name:  key,
			Error: value.FailureDetails,
		}

		parent, found := util.GetParent(a.Client, value.ValidatingWebhook.ObjectMeta)
		if found {
			currentAnalysis.ParentObject = parent
		}
		a.Results = append(a.Results, currentAnalysis)
	}

	return a.Results, nil
}
/*
Copyright 2024 The K8sGPT Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package analyzer

import (
	"context"
	"testing"

	"github.com/k8sgpt-ai/k8sgpt/pkg/common"
	"github.com/k8sgpt-ai/k8sgpt/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"
)

func TestValidatingWebhookAnalyzer(t *testing.T) {
	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: fake.NewSimpleClientset(
				&v1.Pod{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "Pod1",
						Namespace: "default",
						Labels: map[string]string{
							"pod": "Pod1",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service1",
						Namespace: "default",
					},
					Spec: v1.ServiceSpec{
						Selector: map[string]string{
							"pod": "Pod1",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service2",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						// No such pod exists in the test namespace
						Selector: map[string]string{
							"pod": "Pod2",
						},
					},
				},
				&v1.Service{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-service3",
						Namespace: "test",
					},
					Spec: v1.ServiceSpec{
						// len(service.Spec.Selector) == 0
						Selector: map[string]string{},
					},
				},
				&admissionregistrationv1.ValidatingWebhookConfiguration{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "test-validating-webhook-config",
						Namespace: "test",
					},
					Webhooks: []admissionregistrationv1.ValidatingWebhook{
						{
							// Failure: Pointing to an inactive receiver pod
							Name: "webhook1",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service1",
									Namespace: "default",
								},
							},
						},
						{
							// Failure: No active pods found in the test namespace
							Name: "webhook2",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service2",
									Namespace: "test",
								},
							},
						},
						{
							Name: "webhook3",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service3",
									Namespace: "test",
								},
							},
						},
						{
							// Failure: Service doesn't exist.
							Name: "webhook4",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{
								Service: &admissionregistrationv1.ServiceReference{
									Name:      "test-service4-doesn't-exist",
									Namespace: "test",
								},
							},
						},
						{
							// Service is nil.
							Name:         "webhook5",
							ClientConfig: admissionregistrationv1.WebhookClientConfig{},
						},
					},
				},
			),
		},
		Context:   context.Background(),
		Namespace: "default",
	}

	vwAnalyzer := ValidatingWebhookAnalyzer{}
	results, err := vwAnalyzer.Analyze(config)
	require.NoError(t, err)

	// The results should contain: webhook1, webhook2, and webhook4
	resultsLen := 3
	require.Equal(t, resultsLen, len(results))
}

func TestValidatingWebhookAnalyzerLabelSelectorFiltering(t *testing.T) {
	clientSet := fake.NewSimpleClientset(
		&admissionregistrationv1.ValidatingWebhookConfiguration{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-validating-webhook-config1",
				Namespace: "default",
				Labels: map[string]string{
					"app":     "validating-webhook",
					"part-of": "test",
				},
			},
			Webhooks: []admissionregistrationv1.ValidatingWebhook{
				{
					// Failure: Pointing to an inactive receiver pod
					Name: "webhook1",
					ClientConfig: admissionregistrationv1.WebhookClientConfig{
						Service: &admissionregistrationv1.ServiceReference{
							Name:      "test-service1",
							Namespace: "default",
						},
					},
				},
			},
		},
		&admissionregistrationv1.ValidatingWebhookConfiguration{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-validating-webhook-config2",
				Namespace: "default",
			},
			Webhooks: []admissionregistrationv1.ValidatingWebhook{
				{
					// Failure: Pointing to an inactive receiver pod
					Name: "webhook1",
					ClientConfig: admissionregistrationv1.WebhookClientConfig{
						Service: &admissionregistrationv1.ServiceReference{
							Name:      "test-service1",
							Namespace: "default",
						},
					},
				},
			},
		},
	)

	config := common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=validating-webhook",
	}

	vwAnalyzer := ValidatingWebhookAnalyzer{}
	results, err := vwAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	require.Equal(t, 1, len(results))

	config = common.Analyzer{
		Client: &kubernetes.Client{
			Client: clientSet,
		},
		Context:       context.Background(),
		Namespace:     "default",
		LabelSelector: "app=validating-webhook,part-of=test",
	}

	vwAnalyzer = ValidatingWebhookAnalyzer{}
	results, err = vwAnalyzer.Analyze(config)
	if err != nil {
		t.Error(err)
	}
	require.Equal(t, 1, len(results))
}
